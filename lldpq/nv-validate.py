#!/usr/bin/env python3
"""
NVUE YAML Configuration Validator

This script validates NVUE YAML configuration files generated by Ansible
and reports specific errors and warnings.

Usage:
    python nvue_yaml_validator.py <yaml_file>           # Validate single file
    python nvue_yaml_validator.py --dir <directory>     # Validate all files in directory
    python nvue_yaml_validator.py                       # Validate all files in default directory

Based on Cumulus Linux NVUE Format Reference documentation.
"""

import yaml
import argparse
import sys
import re
import ipaddress
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Tuple
from enum import Enum


# Default paths (relative to script location)
SCRIPT_DIR = Path(__file__).parent
DEFAULT_INPUT_DIR = SCRIPT_DIR / "../files/generated_config_folder"


class Severity(Enum):
    ERROR = "ERROR"
    WARNING = "WARNING"
    INFO = "INFO"


@dataclass
class ValidationIssue:
    """Represents a validation issue found in the config."""
    severity: Severity
    path: str
    message: str
    suggestion: Optional[str] = None

    def __str__(self):
        result = f"[{self.severity.value}] {self.path}: {self.message}"
        if self.suggestion:
            result += f"\n         â†’ Suggestion: {self.suggestion}"
        return result


@dataclass
class ValidationResult:
    """Result of validating a YAML file."""
    filename: str
    issues: List[ValidationIssue] = field(default_factory=list)
    
    @property
    def error_count(self) -> int:
        return sum(1 for i in self.issues if i.severity == Severity.ERROR)
    
    @property
    def warning_count(self) -> int:
        return sum(1 for i in self.issues if i.severity == Severity.WARNING)
    
    @property
    def is_valid(self) -> bool:
        return self.error_count == 0


# ============================================================================
# VALIDATION PATTERNS (Based on NVUE Format Reference)
# ============================================================================

# Reserved names that cannot be used
RESERVED_NAMES = {'auto', 'none', 'null', 'any', 'all'}

# Valid interface name patterns
INTERFACE_PATTERNS = {
    'swp': re.compile(r'^swp(\d+)(s\d+)?(L)?$'),
    'eth': re.compile(r'^eth\d+$'),
    'bond': re.compile(r'^[a-zA-Z][a-zA-Z0-9_]*$'),
    'vlan': re.compile(r'^vlan(\d+|[a-zA-Z0-9_]+)(-v0)?$'),
    'lo': re.compile(r'^lo$'),
    'mgmt': re.compile(r'^eth0$'),
}

# Valid VLAN ID range
VLAN_MIN = 1
VLAN_MAX = 4094

# Valid MTU range
MTU_MIN = 552
MTU_MAX = 9216

# Valid ASN range
ASN_MIN = 1
ASN_MAX = 4294967295

# Valid speed values
VALID_SPEEDS = {
    '10M', '100M', '1G', '10G', '25G', '40G', '50G', '100G', '200G', '400G', '800G',
    'auto'
}

# Valid interface types
VALID_INTERFACE_TYPES = {'swp', 'bond', 'svi', 'sub', 'loopback', 'eth', 'peerlink'}

# Valid bridge domain names
VALID_BRIDGE_DOMAINS = {'br_default'}

# Valid on/off values (NVUE accepts both formats)
VALID_ON_OFF = {'on', 'off', 'enabled', 'disabled'}

# Valid STP modes
VALID_STP_MODES = {'rstp', 'pvrst'}

# Valid bond modes
VALID_BOND_MODES = {'lacp', 'static'}

# Valid BGP peer types
VALID_BGP_PEER_TYPES = {'external', 'internal'}

# Valid BGP neighbor types
VALID_BGP_NEIGHBOR_TYPES = {'unnumbered', 'numbered'}

# Valid VNI range
VNI_MIN = 1
VNI_MAX = 16777215

# Valid VRR MAC pattern
VRR_MAC_PATTERN = re.compile(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$')

# Valid route-export/import options
VALID_ROUTE_EXPORT_OPTIONS = {'to-evpn'}

# Valid address families
VALID_ADDRESS_FAMILIES = {'ipv4-unicast', 'ipv6-unicast', 'l2vpn-evpn'}


# ============================================================================
# VALIDATION FUNCTIONS
# ============================================================================

class NVUEValidator:
    """NVUE YAML Configuration Validator."""
    
    def __init__(self):
        self.issues: List[ValidationIssue] = []
        self.defined_vlans: set = set()
        self.defined_vrfs: set = set()
        self.defined_interfaces: set = set()
        self.defined_bonds: set = set()
    
    def add_error(self, path: str, message: str, suggestion: str = None):
        self.issues.append(ValidationIssue(Severity.ERROR, path, message, suggestion))
    
    def add_warning(self, path: str, message: str, suggestion: str = None):
        self.issues.append(ValidationIssue(Severity.WARNING, path, message, suggestion))
    
    def add_info(self, path: str, message: str, suggestion: str = None):
        self.issues.append(ValidationIssue(Severity.INFO, path, message, suggestion))
    
    def validate(self, yaml_content: Any, filename: str) -> ValidationResult:
        """Main validation entry point."""
        self.issues = []
        self.defined_vlans = set()
        self.defined_vrfs = set()
        self.defined_interfaces = set()
        self.defined_bonds = set()
        
        if yaml_content is None:
            self.add_error("root", "YAML file is empty or invalid")
            return ValidationResult(filename, self.issues)
        
        # NVUE YAML should be a list
        if not isinstance(yaml_content, list):
            self.add_error("root", "NVUE YAML must be a list (must start with '- set:')",
                          "File must start with '- set:'")
            return ValidationResult(filename, self.issues)
        
        # First pass: Check for empty/null values throughout the structure
        self._check_empty_values(yaml_content, "root")
        
        # Process each set block
        for idx, item in enumerate(yaml_content):
            if not isinstance(item, dict):
                self.add_error(f"[{idx}]", "List item must be a dict")
                continue
            
            if 'set' not in item:
                self.add_warning(f"[{idx}]", "'set' key not found",
                               "Each block must start with 'set:'")
                continue
            
            self._validate_set_block(item['set'], f"[{idx}].set")
        
        return ValidationResult(filename, self.issues)
    
    def _check_empty_values(self, data: Any, path: str, parent_key: str = None):
        """Recursively check for empty/null values that might cause issues."""
        # Keys that are allowed to be empty (they're just markers/flags)
        ALLOWED_EMPTY_KEYS = {
            'inbound', 'outbound', 'up', 'down', 'state', 
            'l2', 'l3', 'tunnel', 'forwarding'
        }
        
        # Keys where empty dict {} is valid (used as markers)
        VALID_EMPTY_DICT_PATTERNS = {
            'iburst', 'summary-only', 'permit', 'deny'
        }
        
        if data is None:
            # Null value found - this often causes issues
            if parent_key and parent_key.lower() not in ALLOWED_EMPTY_KEYS:
                self.add_error(path, 
                             f"Field '{parent_key}' is null/empty - this will likely cause an error",
                             f"Either provide a value or remove the '{parent_key}' field")
        elif isinstance(data, dict):
            if len(data) == 0:
                # Empty dict - might be intentional or a problem
                if parent_key and parent_key.lower() not in ALLOWED_EMPTY_KEYS:
                    # Check if this empty dict is used as a value marker
                    if not any(pattern in path.lower() for pattern in VALID_EMPTY_DICT_PATTERNS):
                        # Don't warn for common patterns like "192.168.1.1/24: {}"
                        if not (parent_key and ('/' in str(parent_key) or ':' in str(parent_key))):
                            pass  # Skip - empty dicts like {} are often valid as value markers
            else:
                for key, value in data.items():
                    child_path = f"{path}.{key}"
                    self._check_empty_values(value, child_path, key)
        elif isinstance(data, list):
            for idx, item in enumerate(data):
                child_path = f"{path}[{idx}]"
                self._check_empty_values(item, child_path, parent_key)
        elif isinstance(data, str) and data.strip() == '':
            # Empty string
            if parent_key and parent_key.lower() not in ALLOWED_EMPTY_KEYS:
                self.add_warning(path,
                               f"Field '{parent_key}' is an empty string",
                               "Provide a value or remove the field")
    
    def _validate_set_block(self, data: Dict, path: str):
        """Validate a 'set' block."""
        if not isinstance(data, dict):
            self.add_error(path, "'set' block must be a dict")
            return
        
        # Validate each top-level section
        for key, value in data.items():
            section_path = f"{path}.{key}"
            
            if key == 'system':
                self._validate_system(value, section_path)
            elif key == 'interface':
                self._validate_interfaces(value, section_path)
            elif key == 'bridge':
                self._validate_bridge(value, section_path)
            elif key == 'router':
                self._validate_router(value, section_path)
            elif key == 'vrf':
                self._validate_vrfs(value, section_path)
            elif key == 'service':
                self._validate_service(value, section_path)
            elif key == 'evpn':
                self._validate_evpn(value, section_path)
            elif key == 'nve':
                self._validate_nve(value, section_path)
            elif key == 'qos':
                self._validate_qos(value, section_path)
            elif key == 'acl':
                self._validate_acl(value, section_path)
            elif key == 'global':
                self._validate_global(value, section_path)
            elif key == 'mlag':
                self._validate_mlag(value, section_path)
            elif key == 'lldp':
                self._validate_lldp(value, section_path)
            elif key == 'platform':
                pass  # Platform settings
            elif key == 'system':
                pass  # Already handled above
            else:
                self.add_warning(section_path, f"Unknown top-level section: '{key}'")
    
    # ========================================================================
    # SYSTEM VALIDATION
    # ========================================================================
    
    def _validate_system(self, data: Dict, path: str):
        """Validate system configuration."""
        if not isinstance(data, dict):
            self.add_error(path, "system section must be a dict")
            return
        
        for key, value in data.items():
            section_path = f"{path}.{key}"
            
            if key == 'hostname':
                self._validate_hostname(value, section_path)
            elif key == 'timezone':
                self._validate_timezone(value, section_path)
            elif key == 'message':
                pass  # MOTD, usually OK
            elif key == 'aaa':
                self._validate_aaa(value, section_path)
            elif key == 'api':
                self._validate_api(value, section_path)
            elif key == 'control-plane':
                self._validate_control_plane(value, section_path)
            elif key == 'snmp-server':
                self._validate_snmp(value, section_path)
            elif key == 'syslog':
                self._validate_syslog(value, section_path)
            elif key == 'telemetry':
                self._validate_system_telemetry(value, section_path)
            elif key == 'config':
                self._validate_system_config(value, section_path)
            elif key == 'ssh-server':
                self._validate_ssh_server(value, section_path)
            elif key == 'reboot':
                pass  # Reboot settings
            elif key == 'wjh':
                self._validate_wjh(value, section_path)
            elif key == 'global':
                pass  # Global settings handled separately
    
    def _validate_syslog(self, data: Dict, path: str):
        """Validate syslog configuration."""
        if not isinstance(data, dict):
            return
        
        if 'server' in data:
            servers = data['server']
            if isinstance(servers, dict):
                for server_ip, server_config in servers.items():
                    server_path = f"{path}.server.{server_ip}"
                    
                    if not self._is_valid_ip(server_ip):
                        self.add_error(server_path,
                                     f"Invalid syslog server IP: '{server_ip}'")
                    
                    if isinstance(server_config, dict):
                        # Validate port
                        if 'port' in server_config:
                            port = server_config['port']
                            if isinstance(port, int) and (port < 1 or port > 65535):
                                self.add_error(f"{server_path}.port",
                                             f"Port must be between 1-65535: {port}")
                        
                        # Validate protocol
                        if 'protocol' in server_config:
                            protocol = server_config['protocol']
                            if protocol not in ['udp', 'tcp']:
                                self.add_error(f"{server_path}.protocol",
                                             f"Invalid protocol: '{protocol}' (must be udp or tcp)")
                        
                        # Validate VRF
                        if 'vrf' in server_config:
                            vrf = server_config['vrf']
                            if vrf not in ['mgmt', 'default'] and vrf.lower() in RESERVED_NAMES:
                                self.add_warning(f"{server_path}.vrf",
                                               f"VRF should be verified: '{vrf}'")
    
    def _validate_api(self, data: Dict, path: str):
        """Validate API configuration."""
        if not isinstance(data, dict):
            return
        
        if 'state' in data:
            state = data['state']
            if state not in ['enabled', 'disabled']:
                self.add_error(f"{path}.state",
                             f"Invalid state: '{state}' (must be enabled or disabled)")
        
        if 'listening-address' in data:
            addresses = data['listening-address']
            if isinstance(addresses, dict):
                for addr in addresses.keys():
                    if not self._is_valid_ip(addr):
                        self.add_error(f"{path}.listening-address.{addr}",
                                     f"Invalid API listening IP: '{addr}'")
    
    def _validate_control_plane(self, data: Dict, path: str):
        """Validate control-plane configuration."""
        if not isinstance(data, dict):
            return
        
        if 'acl' in data:
            acls = data['acl']
            if isinstance(acls, dict):
                for acl_name, acl_config in acls.items():
                    if isinstance(acl_config, dict):
                        for direction in acl_config.keys():
                            if direction not in ['inbound', 'outbound']:
                                self.add_warning(f"{path}.acl.{acl_name}.{direction}",
                                               f"Unknown ACL direction: '{direction}'")
    
    def _validate_system_telemetry(self, data: Dict, path: str):
        """Validate system telemetry configuration."""
        if not isinstance(data, dict):
            return
        
        if 'enable' in data:
            val = data['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_system_config(self, data: Dict, path: str):
        """Validate system config settings."""
        if not isinstance(data, dict):
            return
        
        if 'auto-save' in data:
            auto_save = data['auto-save']
            if isinstance(auto_save, dict):
                if 'state' in auto_save:
                    state = auto_save['state']
                    if state not in ['enabled', 'disabled']:
                        self.add_error(f"{path}.auto-save.state",
                                     f"Invalid state: '{state}'")
                if 'enable' in auto_save:
                    val = auto_save['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.auto-save.enable",
                                     f"Invalid value: '{val}'")
    
    def _validate_ssh_server(self, data: Dict, path: str):
        """Validate SSH server configuration."""
        if not isinstance(data, dict):
            return
        
        if 'state' in data:
            state = data['state']
            if state not in ['enabled', 'disabled']:
                self.add_error(f"{path}.state",
                             f"Invalid state: '{state}' (must be enabled or disabled)")
        
        if 'vrf' in data:
            vrfs = data['vrf']
            if isinstance(vrfs, dict):
                for vrf_name in vrfs.keys():
                    if vrf_name.lower() in RESERVED_NAMES:
                        self.add_warning(f"{path}.vrf.{vrf_name}",
                                       f"VRF name should be verified: '{vrf_name}'")
    
    def _validate_wjh(self, data: Dict, path: str):
        """Validate WJH (What Just Happened) configuration."""
        if not isinstance(data, dict):
            return
        
        if 'enable' in data:
            val = data['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        if 'channel' in data:
            channel = data['channel']
            if isinstance(channel, dict) and 'forwarding' in channel:
                fwd = channel['forwarding']
                if isinstance(fwd, dict) and 'trigger' in fwd:
                    trigger = fwd['trigger']
                    if isinstance(trigger, dict):
                        valid_triggers = {'l2', 'l3', 'tunnel', 'acl'}
                        for trig in trigger.keys():
                            if trig not in valid_triggers:
                                self.add_warning(f"{path}.channel.forwarding.trigger.{trig}",
                                               f"Unknown WJH trigger: '{trig}'")
    
    def _validate_hostname(self, hostname: str, path: str):
        """Validate hostname."""
        if not isinstance(hostname, str):
            self.add_error(path, "hostname must be a string")
            return
        
        if len(hostname) > 64:
            self.add_error(path, f"hostname 64 characters maximum (currently: {len(hostname)})")
        
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9\-]*$', hostname):
            self.add_error(path, "Hostname must start with a letter and contain only letters, digits, or hyphens")
        
        if hostname.lower() in RESERVED_NAMES:
            self.add_error(path, f"'{hostname}' is a reserved name")
    
    def _validate_timezone(self, value: Any, path: str):
        """Validate timezone setting."""
        if isinstance(value, str):
            # Simple timezone string
            pass
        elif isinstance(value, dict):
            # Could be nested structure
            pass
    
    def _validate_aaa(self, data: Dict, path: str):
        """Validate AAA configuration."""
        if not isinstance(data, dict):
            return
        
        if 'user' in data and isinstance(data['user'], dict):
            for username, user_config in data['user'].items():
                user_path = f"{path}.user.{username}"
                self._validate_username(username, user_path)
    
    def _validate_username(self, username: str, path: str):
        """Validate username format."""
        if len(username) > 32:
            self.add_error(path, f"Username 32 characters maximum")
        
        if username.lower() in RESERVED_NAMES:
            self.add_error(path, f"'{username}' is a reserved name")
        
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_\-]*\$?$', username):
            self.add_error(path, "Username letter or _ must start with")
    
    def _validate_snmp(self, data: Dict, path: str):
        """Validate SNMP configuration."""
        if not isinstance(data, dict):
            return
        
        # Validate state
        if 'state' in data:
            state = data['state']
            if state not in ['enabled', 'disabled']:
                self.add_error(f"{path}.state",
                             f"Invalid state: '{state}' (must be enabled or disabled)")
        
        # Check listening address if specified
        if 'listening-address' in data:
            addresses = data['listening-address']
            if isinstance(addresses, dict):
                for addr in addresses.keys():
                    addr_clean = addr.split(':')[0]
                    if not self._is_valid_ip(addr_clean):
                        self.add_error(f"{path}.listening-address.{addr}",
                                     f"Invalid IP address: {addr}")
        
        # Validate readonly-community (SNMPv2)
        if 'readonly-community' in data:
            communities = data['readonly-community']
            if isinstance(communities, dict):
                for comm_name, comm_config in communities.items():
                    if isinstance(comm_config, dict) and 'access' in comm_config:
                        access = comm_config['access']
                        if isinstance(access, dict):
                            for host in access.keys():
                                if host != 'any' and not self._is_valid_ip_prefix(host) and not self._is_valid_ip(host):
                                    self.add_warning(f"{path}.readonly-community.{comm_name}.access.{host}",
                                                   f"Access host should be verified: '{host}'")
        
        # Validate username (SNMPv3)
        if 'username' in data:
            users = data['username']
            if isinstance(users, dict):
                for username in users.keys():
                    if len(username) > 32:
                        self.add_error(f"{path}.username.{username}",
                                     "SNMP username 32 characters maximum")
        
        # Validate trap-destination
        if 'trap-destination' in data:
            traps = data['trap-destination']
            if isinstance(traps, dict):
                for trap_host in traps.keys():
                    if not self._is_valid_ip(trap_host):
                        self.add_error(f"{path}.trap-destination.{trap_host}",
                                     f"Invalid trap destination IP: '{trap_host}'")
    
    # ========================================================================
    # INTERFACE VALIDATION
    # ========================================================================
    
    def _validate_interfaces(self, data: Dict, path: str):
        """Validate interface configurations."""
        if not isinstance(data, dict):
            self.add_error(path, "interface section must be a dict")
            return
        
        for iface_name, iface_config in data.items():
            iface_path = f"{path}.{iface_name}"
            self._validate_interface(iface_name, iface_config, iface_path)
    
    def _validate_interface(self, name: str, config: Dict, path: str):
        """Validate a single interface."""
        if not isinstance(config, dict):
            self.add_error(path, "Interface configuration must be a dict")
            return
        
        # Track defined interface
        self.defined_interfaces.add(name)
        
        # Validate interface name
        if not self._is_valid_interface_name(name):
            self.add_warning(path, f"Interface name does not match standard format: '{name}'",
                           "Use formats like: swp1, swp1.100 (sub-if), bond1, vlan100, lo, eth0")
        
        # Check for type field - REQUIRED for most interfaces
        iface_type = config.get('type')
        if iface_type:
            if iface_type not in VALID_INTERFACE_TYPES:
                self.add_warning(f"{path}.type", f"Unknown interface type: '{iface_type}'",
                               f"Valid types: {', '.join(VALID_INTERFACE_TYPES)}")
        else:
            # Type is required for interfaces (except some special cases)
            if name not in ['eth0', 'lo'] and not name.startswith('peerlink'):
                self.add_warning(path,
                               f"Interface '{name}' 'type' is not defined",
                               "type: swp, bond, svi, sub, or loopback")
        
        # Validate specific fields
        if 'link' in config:
            self._validate_link_config(config['link'], f"{path}.link")
        
        if 'bridge' in config:
            self._validate_interface_bridge(config['bridge'], f"{path}.bridge", name)
        
        if 'ip' in config:
            self._validate_interface_ip(config['ip'], f"{path}.ip")
        
        if 'bond' in config:
            self._validate_bond_config(config['bond'], f"{path}.bond", name)
            self.defined_bonds.add(name)
        
        if 'evpn' in config:
            self._validate_interface_evpn(config['evpn'], f"{path}.evpn")
        
        if 'router' in config:
            self._validate_interface_router(config['router'], f"{path}.router")
        
        # SVI-specific validation
        if iface_type == 'svi' or name.startswith('vlan'):
            self._validate_svi_interface(name, config, path)
        
        # Sub-interface specific validation
        if iface_type == 'sub' or '.' in name:
            self._validate_sub_interface(name, config, path)
        
        # ACL validation
        if 'acl' in config:
            self._validate_interface_acl(config['acl'], f"{path}.acl")
        
        # Storm control validation
        if 'storm-control' in config:
            self._validate_storm_control(config['storm-control'], f"{path}.storm-control")
        
        # LLDP interface settings
        if 'lldp' in config:
            self._validate_interface_lldp(config['lldp'], f"{path}.lldp")
    
    def _validate_storm_control(self, config: Dict, path: str):
        """Validate storm control configuration."""
        if not isinstance(config, dict):
            return
        
        valid_types = {'broadcast', 'multicast', 'unknown-unicast'}
        
        for storm_type, storm_value in config.items():
            storm_path = f"{path}.{storm_type}"
            
            if storm_type not in valid_types:
                self.add_warning(storm_path,
                               f"Unknown storm control type: '{storm_type}'",
                               f"Valid types: {', '.join(valid_types)}")
            
            # Value should be in pps (packets per second)
            if isinstance(storm_value, int):
                if storm_value < 0:
                    self.add_error(storm_path,
                                 f"Storm control value cannot be negative: {storm_value}")
            elif isinstance(storm_value, dict):
                # Could have nested enable/value structure
                if 'enable' in storm_value:
                    val = storm_value['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{storm_path}.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_interface_lldp(self, config: Dict, path: str):
        """Validate interface LLDP configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate enable
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_sub_interface(self, name: str, config: Dict, path: str):
        """Validate sub-interface specific configuration."""
        # Check if interface name contains VLAN ID suffix (e.g., swp1.100)
        if '.' in name:
            base, name_vlan_suffix = name.rsplit('.', 1)
            
            # Check if 'vlan' field is defined
            if 'vlan' in config:
                config_vlan = str(config['vlan'])
                
                # Compare the VLAN suffix in name with the vlan field
                # This is a warning, not an error - the config will work but naming is inconsistent
                if name_vlan_suffix.isdigit() and config_vlan.isdigit():
                    if name_vlan_suffix != config_vlan:
                        self.add_warning(f"{path}.vlan",
                                       f"Sub-interface name suffix ({name_vlan_suffix}) does not match vlan field ({config_vlan})",
                                       f"Consider renaming interface to {base}.{config_vlan} or change vlan to {name_vlan_suffix}")
            
            # Check for base-interface field
            if 'base-interface' in config:
                base_iface = config['base-interface']
                if base_iface != base:
                    self.add_warning(f"{path}.base-interface",
                                   f"base-interface ({base_iface}) does not match interface name prefix ({base})")
            else:
                # base-interface is typically required for sub-interfaces
                self.add_warning(path,
                               f"Sub-interface '{name}' is missing 'base-interface' field",
                               f"Add: base-interface: {base}")
    
    def _validate_svi_interface(self, name: str, config: Dict, path: str):
        """Validate SVI (VLAN interface) specific configuration."""
        # Check vlan field - REQUIRED for SVI
        if 'vlan' in config:
            vlan_id = config['vlan']
            if not self._is_valid_vlan_id(vlan_id):
                self.add_error(f"{path}.vlan",
                             f"Invalid VLAN ID: {vlan_id}")
            
            # Check consistency with interface name
            if name.startswith('vlan'):
                try:
                    expected_vlan = int(name[4:])
                    if int(vlan_id) != expected_vlan:
                        self.add_warning(f"{path}.vlan",
                                       f"Interface name ({name}) and vlan value ({vlan_id}) do not match")
                except ValueError:
                    pass  # Non-numeric VLAN name
        else:
            if name.startswith('vlan'):
                self.add_error(path, 
                             f"SVI interface '{name}' 'vlan' field is missing",
                             "vlan: <VLAN_ID>")
        
        # Type should be 'svi' for VLAN interfaces
        if 'type' in config and config['type'] != 'svi':
            self.add_warning(f"{path}.type",
                           f"VLAN interface type should be 'svi', but is: '{config['type']}'")
    
    def _validate_interface_acl(self, config: Dict, path: str):
        """Validate interface ACL configuration."""
        if not isinstance(config, dict):
            return
        
        valid_directions = {'inbound', 'outbound'}
        
        for acl_name, acl_config in config.items():
            acl_path = f"{path}.{acl_name}"
            
            if isinstance(acl_config, dict):
                for direction in acl_config.keys():
                    if direction not in valid_directions:
                        self.add_warning(f"{acl_path}.{direction}",
                                       f"Unknown ACL direction: '{direction}'",
                                       f"Valid values: {', '.join(valid_directions)}")
    
    def _is_valid_interface_name(self, name: str) -> bool:
        """Check if interface name is valid."""
        if name.lower() in RESERVED_NAMES:
            return False
        
        # Sub-interface first (e.g., swp1.100, bond1.200)
        if '.' in name:
            base, vid = name.rsplit('.', 1)
            return self._is_valid_interface_name(base) and vid.isdigit()
        
        # Check common patterns
        if name == 'lo':
            return True
        if name.startswith('swp'):
            return bool(INTERFACE_PATTERNS['swp'].match(name))
        if name.startswith('eth'):
            return bool(INTERFACE_PATTERNS['eth'].match(name))
        if name.startswith('vlan'):
            return bool(INTERFACE_PATTERNS['vlan'].match(name))
        if name.startswith('bond'):
            return True
        if name.startswith('peerlink'):
            return True
        
        # Generic bond/interface name
        return bool(re.match(r'^[a-zA-Z][a-zA-Z0-9_\-]*$', name))
    
    def _validate_link_config(self, config: Dict, path: str):
        """Validate link configuration."""
        if not isinstance(config, dict):
            return
        
        # MTU validation
        if 'mtu' in config:
            mtu = config['mtu']
            if isinstance(mtu, int):
                if mtu < MTU_MIN or mtu > MTU_MAX:
                    self.add_error(f"{path}.mtu", 
                                  f"MTU must be between {MTU_MIN}-{MTU_MAX} (currently: {mtu})")
        
        # Speed validation
        if 'speed' in config:
            speed = str(config['speed'])
            if speed not in VALID_SPEEDS:
                self.add_warning(f"{path}.speed", 
                               f"Unknown speed value: '{speed}'",
                               f"Valid values: {', '.join(sorted(VALID_SPEEDS))}")
        
        # Auto-negotiate validation
        if 'auto-negotiate' in config:
            val = config['auto-negotiate']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.auto-negotiate", 
                             f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_interface_bridge(self, config: Dict, path: str, iface_name: str):
        """Validate interface bridge configuration."""
        if not isinstance(config, dict):
            return
        
        if 'domain' not in config:
            self.add_warning(path, "bridge.domain not defined",
                           "Use format: bridge: domain: br_default: ...")
            return
        
        domains = config['domain']
        if not isinstance(domains, dict):
            return
        
        for domain_name, domain_config in domains.items():
            domain_path = f"{path}.domain.{domain_name}"
            
            if domain_name not in VALID_BRIDGE_DOMAINS:
                self.add_warning(domain_path, 
                               f"Non-standard bridge domain: '{domain_name}'",
                               "Usually 'br_default' is used")
            
            if isinstance(domain_config, dict):
                self._validate_bridge_domain_interface(domain_config, domain_path, iface_name)
    
    def _validate_bridge_domain_interface(self, config: Dict, path: str, iface_name: str):
        """Validate bridge domain configuration for an interface."""
        has_access = 'access' in config
        has_vlan = 'vlan' in config
        has_untagged = 'untagged' in config
        
        # Required: either access or vlan must be defined
        if not has_access and not has_vlan:
            self.add_error(path,
                         f"Interface '{iface_name}' has bridge domain but no VLAN configuration",
                         "access: <VLAN_ID> (access port) or vlan: <VLAN_ID>: {} (trunk port)")
        
        # Access and trunk are mutually exclusive
        if has_access and has_vlan:
            self.add_error(path, 
                          "'access' and 'vlan' cannot be used at the same time",
                          "Use only 'access: VLAN_ID' for access port, or 'vlan:' for trunk")
        
        # Validate access VLAN
        if has_access:
            vlan_id = config['access']
            if not self._is_valid_vlan_id(vlan_id):
                self.add_error(f"{path}.access", 
                             f"Invalid VLAN ID: {vlan_id} (must be between 1-4094)")
        
        # Validate trunk VLANs
        if has_vlan:
            self._validate_trunk_vlans(config['vlan'], f"{path}.vlan")
        
        # Validate untagged VLAN
        if has_untagged:
            untagged = config['untagged']
            if not self._is_valid_vlan_id(untagged):
                self.add_error(f"{path}.untagged", 
                             f"Invalid untagged VLAN ID: {untagged}")
            
            # Untagged only makes sense with trunk
            if not has_vlan:
                self.add_warning(f"{path}.untagged",
                               "'untagged' is only meaningful with trunk port",
                               "Use together with 'vlan:'")
        
        # Validate STP settings
        if 'stp' in config:
            self._validate_stp_interface(config['stp'], f"{path}.stp")
    
    def _validate_trunk_vlans(self, config: Dict, path: str):
        """Validate trunk VLAN configuration."""
        if not isinstance(config, dict):
            self.add_error(path, "vlan section must be a dict")
            return
        
        for vlan_key, vlan_value in config.items():
            vlan_path = f"{path}.{vlan_key}"
            
            # 'all' is valid
            if vlan_key == 'all':
                continue
            
            # Check if it's a range (e.g., "100-200")
            if '-' in str(vlan_key):
                self._validate_vlan_range(str(vlan_key), vlan_path)
            else:
                # Single VLAN ID
                try:
                    vlan_id = int(vlan_key)
                    if not self._is_valid_vlan_id(vlan_id):
                        self.add_error(vlan_path, 
                                     f"Invalid VLAN ID: {vlan_id} (must be between 1-4094)")
                except ValueError:
                    self.add_error(vlan_path, 
                                 f"Invalid VLAN value: '{vlan_key}'",
                                 "Numeric VLAN ID, range (100-200) or 'all' use")
    
    def _validate_vlan_range(self, vlan_range: str, path: str):
        """Validate VLAN range format (e.g., '100-200')."""
        parts = vlan_range.split('-')
        if len(parts) != 2:
            self.add_error(path, f"Invalid VLAN range format: '{vlan_range}'",
                          "Format: START-END (e.g. 100-200)")
            return
        
        try:
            start = int(parts[0])
            end = int(parts[1])
            
            if not self._is_valid_vlan_id(start):
                self.add_error(path, f"Range start VLAN ID invalid: {start}")
            
            if not self._is_valid_vlan_id(end):
                self.add_error(path, f"Range end VLAN ID invalid: {end}")
            
            if start >= end:
                self.add_error(path, 
                             f"Range start ({start}) must be less than end ({end})")
        except ValueError:
            self.add_error(path, f"VLAN range must contain numeric values: '{vlan_range}'")
    
    def _is_valid_vlan_id(self, vlan_id: Any) -> bool:
        """Check if VLAN ID is valid."""
        try:
            vid = int(vlan_id)
            return VLAN_MIN <= vid <= VLAN_MAX
        except (ValueError, TypeError):
            return False
    
    def _validate_stp_interface(self, config: Dict, path: str):
        """Validate STP interface settings."""
        if not isinstance(config, dict):
            return
        
        valid_stp_options = {'admin-edge', 'auto-edge', 'bpdu-guard', 'bpdu-filter', 
                            'network', 'portadminedge', 'portautoedge', 'restrrole'}
        
        for key, value in config.items():
            if key not in valid_stp_options:
                self.add_warning(f"{path}.{key}", f"Unknown STP option: '{key}'")
            
            if value not in VALID_ON_OFF and value not in [True, False]:
                self.add_error(f"{path}.{key}", 
                             f"Invalid value: '{value}' (must be on/off)")
    
    def _validate_interface_ip(self, config: Dict, path: str):
        """Validate interface IP configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate IP addresses
        if 'address' in config:
            addresses = config['address']
            # Check for empty address field
            if addresses is None or addresses == '' or addresses == {}:
                # Check if VRR is configured - then real IP might be optional
                if 'vrr' not in config:
                    self.add_warning(f"{path}.address",
                                   "IP address field is defined but empty",
                                   "Add IP address or remove the field")
            elif isinstance(addresses, dict):
                if len(addresses) == 0:
                    if 'vrr' not in config:
                        self.add_warning(f"{path}.address",
                                       "IP address field is empty (no addresses defined)",
                                       "Add IP address: X.X.X.X/prefix: {}")
                for addr in addresses.keys():
                    if not self._is_valid_ip_prefix(addr):
                        self.add_error(f"{path}.address", 
                                     f"Invalid IP address: '{addr}'",
                                     "Format: IP/PREFIX (e.g. 192.168.1.1/24)")
        
        # Validate VRF reference
        if 'vrf' in config:
            vrf = config['vrf']
            self.defined_vrfs.add(vrf)  # Track VRF usage
        
        # Validate VRR (Virtual Router Redundancy)
        if 'vrr' in config:
            self._validate_vrr(config['vrr'], f"{path}.vrr")
    
    def _validate_vrr(self, config: Dict, path: str):
        """Validate VRR (Virtual Router Redundancy) configuration."""
        if not isinstance(config, dict):
            return
        
        is_enabled = config.get('enable') in ['on', True]
        
        # Validate enable
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate MAC address - REQUIRED when enabled
        if 'mac-address' in config:
            mac = config['mac-address']
            if not self._is_valid_mac(mac):
                self.add_error(f"{path}.mac-address",
                             f"Invalid VRR MAC address: '{mac}'",
                             "Format: XX:XX:XX:XX:XX:XX")
        else:
            if is_enabled:
                self.add_error(path, 
                             "VRR is enabled but 'mac-address' is missing",
                             "mac-address: XX:XX:XX:XX:XX:XX")
        
        # Validate VRR addresses - REQUIRED when enabled
        if 'address' in config:
            addresses = config['address']
            if isinstance(addresses, dict):
                if len(addresses) == 0:
                    self.add_error(f"{path}.address",
                                 "VRR for requires at least one VIP address")
                for addr in addresses.keys():
                    if not self._is_valid_ip_prefix(addr):
                        self.add_error(f"{path}.address.{addr}",
                                     f"Invalid VRR VIP address: '{addr}'")
        else:
            if is_enabled:
                self.add_error(path, 
                             "VRR is enabled but 'address' (VIP) is missing",
                             "address: IP/PREFIX: {}")
        
        # Validate state
        if 'state' in config:
            state = config['state']
            if isinstance(state, dict):
                valid_states = {'up', 'down'}
                for s in state.keys():
                    if s not in valid_states:
                        self.add_warning(f"{path}.state.{s}",
                                       f"Unknown VRR state: '{s}'")
    
    def _is_valid_ip(self, ip: str) -> bool:
        """Check if IP address is valid."""
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def _is_valid_ip_prefix(self, ip_prefix: str) -> bool:
        """Check if IP/prefix is valid."""
        try:
            ipaddress.ip_interface(ip_prefix)
            return True
        except ValueError:
            return False
    
    def _validate_bond_config(self, config: Dict, path: str, bond_name: str):
        """Validate bond configuration."""
        if not isinstance(config, dict):
            return
        
        # Required: member ports
        if 'member' not in config:
            self.add_error(path,
                         f"Bond '{bond_name}' 'member' is not defined",
                         "member: swpX: {} format, add at least one port")
        
        # Validate bond mode
        if 'mode' in config:
            mode = config['mode']
            if mode not in VALID_BOND_MODES:
                self.add_error(f"{path}.mode", 
                             f"Invalid bond mode: '{mode}'",
                             f"Valid modes: {', '.join(VALID_BOND_MODES)}")
        else:
            self.add_warning(path,
                           f"Bond '{bond_name}' 'mode' is not defined",
                           "mode: lacp or mode: static")
        
        # Validate member ports
        if 'member' in config:
            members = config['member']
            if isinstance(members, dict):
                for member_port in members.keys():
                    if not self._is_valid_interface_name(member_port):
                        self.add_warning(f"{path}.member.{member_port}",
                                       f"Bond member interface name suspicious: '{member_port}'")
        
        # Validate MLAG settings
        if 'mlag' in config:
            mlag = config['mlag']
            if isinstance(mlag, dict):
                if 'id' in mlag:
                    mlag_id = mlag['id']
                    if not isinstance(mlag_id, int) or mlag_id < 1:
                        self.add_error(f"{path}.mlag.id",
                                     f"MLAG ID must be a positive integer: {mlag_id}")
        
        # lacp-bypass validation
        if 'lacp-bypass' in config:
            val = config['lacp-bypass']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.lacp-bypass",
                             f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_interface_evpn(self, config: Dict, path: str):
        """Validate interface EVPN configuration."""
        if not isinstance(config, dict):
            return
        
        if 'multihoming' in config:
            mh = config['multihoming']
            if isinstance(mh, dict):
                mh_path = f"{path}.multihoming"
                
                # Validate uplink
                if 'uplink' in mh:
                    val = mh['uplink']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{mh_path}.uplink",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                # Validate segment settings
                if 'segment' in mh:
                    segment = mh['segment']
                    if isinstance(segment, dict):
                        seg_path = f"{mh_path}.segment"
                        
                        # Validate enable
                        if 'enable' in segment:
                            val = segment['enable']
                            if val not in VALID_ON_OFF and val not in [True, False]:
                                self.add_error(f"{seg_path}.enable",
                                             f"Invalid value: '{val}' (must be on/off)")
                        
                        # Validate local-id
                        if 'local-id' in segment:
                            local_id = segment['local-id']
                            if not isinstance(local_id, int) or local_id < 1:
                                self.add_error(f"{seg_path}.local-id",
                                             f"local-id must be a positive integer: {local_id}")
                        
                        # Validate MAC address (ES system MAC)
                        if 'mac-address' in segment:
                            mac = segment['mac-address']
                            if not self._is_valid_mac(mac):
                                self.add_error(f"{seg_path}.mac-address",
                                             f"Invalid ES MAC address: '{mac}'")
                        
                        # Validate df-preference (Designated Forwarder preference)
                        if 'df-preference' in segment:
                            df_pref = segment['df-preference']
                            if isinstance(df_pref, int):
                                if df_pref < 0 or df_pref > 65535:
                                    self.add_error(f"{seg_path}.df-preference",
                                                 f"df-preference must be between 0-65535: {df_pref}")
                        
                        # Check for required fields when enabled
                        if segment.get('enable') in ['on', True]:
                            if 'local-id' not in segment:
                                self.add_warning(seg_path,
                                               "EVPN-MH segment requires local-id")
                            if 'mac-address' not in segment:
                                self.add_warning(seg_path,
                                               "EVPN-MH segment requires mac-address")
    
    def _is_valid_mac(self, mac: str) -> bool:
        """Check if MAC address is valid."""
        pattern = re.compile(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$')
        return bool(pattern.match(mac))
    
    def _validate_interface_router(self, config: Dict, path: str):
        """Validate interface router configuration."""
        if not isinstance(config, dict):
            return
        
        # Adaptive routing
        if 'adaptive-routing' in config:
            ar = config['adaptive-routing']
            if isinstance(ar, dict) and 'enable' in ar:
                val = ar['enable']
                if val not in VALID_ON_OFF and val not in [True, False]:
                    self.add_error(f"{path}.adaptive-routing.enable",
                                 f"Invalid value: '{val}' (must be on/off)")
        
        # PIM (Protocol Independent Multicast)
        if 'pim' in config:
            pim = config['pim']
            if isinstance(pim, dict) and 'enable' in pim:
                val = pim['enable']
                if val not in VALID_ON_OFF and val not in [True, False]:
                    self.add_error(f"{path}.pim.enable",
                                 f"Invalid value: '{val}' (must be on/off)")
        
        # OSPF interface settings
        if 'ospf' in config:
            self._validate_interface_ospf(config['ospf'], f"{path}.ospf")
    
    def _validate_interface_ospf(self, config: Dict, path: str):
        """Validate interface OSPF configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate enable
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate area
        if 'area' in config:
            area = config['area']
            if area != '0' and not self._is_valid_ip(str(area)):
                try:
                    int(area)
                except (ValueError, TypeError):
                    self.add_warning(f"{path}.area",
                                   f"OSPF area format should be verified: '{area}'")
        
        # Validate network-type
        if 'network-type' in config:
            network_type = config['network-type']
            valid_types = {'broadcast', 'point-to-point', 'non-broadcast', 'point-to-multipoint'}
            if network_type not in valid_types:
                self.add_error(f"{path}.network-type",
                             f"Invalid OSPF network type: '{network_type}'",
                             f"Valid types: {', '.join(valid_types)}")
        
        # Validate timers
        if 'timers' in config:
            timers = config['timers']
            if isinstance(timers, dict):
                for timer in ['hello-interval', 'dead-interval', 'retransmit-interval']:
                    if timer in timers:
                        val = timers[timer]
                        if isinstance(val, int) and val < 1:
                            self.add_error(f"{path}.timers.{timer}",
                                         f"OSPF timer must be positive: {val}")
        
        # Validate cost
        if 'cost' in config:
            cost = config['cost']
            if isinstance(cost, int):
                if cost < 1 or cost > 65535:
                    self.add_error(f"{path}.cost",
                                 f"OSPF cost must be between 1-65535: {cost}")
        
        # Validate priority
        if 'priority' in config:
            priority = config['priority']
            if isinstance(priority, int):
                if priority < 0 or priority > 255:
                    self.add_error(f"{path}.priority",
                                 f"OSPF priority must be between 0-255: {priority}")
        
        # Validate passive
        if 'passive' in config:
            val = config['passive']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.passive",
                             f"Invalid value: '{val}' (must be on/off)")
    
    # ========================================================================
    # BRIDGE VALIDATION
    # ========================================================================
    
    def _validate_bridge(self, data: Dict, path: str):
        """Validate bridge configuration."""
        if not isinstance(data, dict):
            self.add_error(path, "bridge section must be a dict")
            return
        
        if 'domain' in data:
            domains = data['domain']
            if isinstance(domains, dict):
                for domain_name, domain_config in domains.items():
                    domain_path = f"{path}.domain.{domain_name}"
                    self._validate_bridge_domain(domain_config, domain_path)
    
    def _validate_bridge_domain(self, config: Dict, path: str):
        """Validate bridge domain configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate VLANs
        if 'vlan' in config:
            vlans = config['vlan']
            if isinstance(vlans, dict):
                for vlan_id, vlan_config in vlans.items():
                    vlan_path = f"{path}.vlan.{vlan_id}"
                    
                    try:
                        vid = int(vlan_id)
                        if not self._is_valid_vlan_id(vid):
                            self.add_error(vlan_path,
                                         f"Invalid VLAN ID: {vid}")
                        self.defined_vlans.add(vid)
                    except ValueError:
                        self.add_error(vlan_path,
                                     f"VLAN ID must be numeric: '{vlan_id}'")
                    
                    # Validate VLAN configuration
                    if isinstance(vlan_config, dict):
                        self._validate_vlan_config(vlan_config, vlan_path)
        
        # Validate STP
        if 'stp' in config:
            self._validate_stp_global(config['stp'], f"{path}.stp")
        
        # Validate multicast snooping
        if 'multicast' in config:
            self._validate_multicast_snooping(config['multicast'], f"{path}.multicast")
    
    def _validate_vlan_config(self, config: Dict, path: str):
        """Validate VLAN configuration."""
        # VNI validation (L2VNI)
        if 'vni' in config:
            vni_config = config['vni']
            if isinstance(vni_config, dict):
                for vni_id in vni_config.keys():
                    try:
                        vni = int(vni_id)
                        if vni < VNI_MIN or vni > VNI_MAX:
                            self.add_error(f"{path}.vni.{vni_id}",
                                         f"L2VNI must be between {VNI_MIN}-{VNI_MAX}: {vni}")
                    except ValueError:
                        self.add_error(f"{path}.vni.{vni_id}",
                                     f"VNI must be numeric: '{vni_id}'")
    
    def _validate_multicast_snooping(self, config: Dict, path: str):
        """Validate IGMP/MLD snooping configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate snooping enable
        if 'snooping' in config:
            snooping = config['snooping']
            if isinstance(snooping, dict):
                if 'enable' in snooping:
                    val = snooping['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.snooping.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
        
        # Validate querier
        if 'querier' in config:
            querier = config['querier']
            if isinstance(querier, dict):
                if 'enable' in querier:
                    val = querier['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.querier.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                # Validate source-ip
                if 'source-ip' in querier:
                    ip = querier['source-ip']
                    if not self._is_valid_ip(ip):
                        self.add_error(f"{path}.querier.source-ip",
                                     f"Invalid querier source IP: '{ip}'")
    
    def _validate_stp_global(self, config: Dict, path: str):
        """Validate global STP configuration."""
        if not isinstance(config, dict):
            return
        
        if 'mode' in config:
            mode = config['mode']
            if mode not in VALID_STP_MODES:
                self.add_warning(f"{path}.mode",
                               f"Unknown STP mode: '{mode}'",
                               f"Valid modes: {', '.join(VALID_STP_MODES)}")
        
        if 'priority' in config:
            priority = config['priority']
            if isinstance(priority, int):
                if priority < 0 or priority > 61440 or priority % 4096 != 0:
                    self.add_error(f"{path}.priority",
                                 f"STP priority must be 0-61440 and multiple of 4096: {priority}")
    
    # ========================================================================
    # ROUTER VALIDATION
    # ========================================================================
    
    def _validate_router(self, data: Dict, path: str):
        """Validate router configuration."""
        if not isinstance(data, dict):
            return
        
        if 'bgp' in data:
            self._validate_router_bgp(data['bgp'], f"{path}.bgp")
        
        if 'vrr' in data:
            vrr = data['vrr']
            if isinstance(vrr, dict) and 'enable' in vrr:
                val = vrr['enable']
                if val not in VALID_ON_OFF and val not in [True, False]:
                    self.add_error(f"{path}.vrr.enable",
                                 f"Invalid value: '{val}' (must be on/off)")
        
        if 'adaptive-routing' in data:
            ar = data['adaptive-routing']
            if isinstance(ar, dict) and 'enable' in ar:
                val = ar['enable']
                if val not in VALID_ON_OFF and val not in [True, False]:
                    self.add_error(f"{path}.adaptive-routing.enable",
                                 f"Invalid value: '{val}' (must be on/off)")
        
        if 'policy' in data:
            self._validate_router_policy(data['policy'], f"{path}.policy")
    
    def _validate_router_policy(self, config: Dict, path: str):
        """Validate router policy (prefix-list, route-map) configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate prefix-list
        if 'prefix-list' in config:
            prefix_lists = config['prefix-list']
            if isinstance(prefix_lists, dict):
                for pl_name, pl_config in prefix_lists.items():
                    pl_path = f"{path}.prefix-list.{pl_name}"
                    self._validate_prefix_list(pl_name, pl_config, pl_path)
        
        # Validate route-map
        if 'route-map' in config:
            route_maps = config['route-map']
            if isinstance(route_maps, dict):
                for rm_name, rm_config in route_maps.items():
                    rm_path = f"{path}.route-map.{rm_name}"
                    self._validate_route_map(rm_name, rm_config, rm_path)
    
    def _validate_prefix_list(self, name: str, config: Dict, path: str):
        """Validate prefix-list configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate type
        if 'type' in config:
            pl_type = config['type']
            if pl_type not in ['ipv4', 'ipv6']:
                self.add_error(f"{path}.type",
                             f"Invalid prefix-list type: '{pl_type}'",
                             "Valid values: ipv4, ipv6")
        
        # Validate rules
        if 'rule' in config:
            rules = config['rule']
            if isinstance(rules, dict):
                for rule_id, rule_config in rules.items():
                    rule_path = f"{path}.rule.{rule_id}"
                    self._validate_prefix_list_rule(rule_config, rule_path)
    
    def _validate_prefix_list_rule(self, config: Dict, path: str):
        """Validate prefix-list rule configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate action
        if 'action' in config:
            action = config['action']
            if action not in ['permit', 'deny']:
                self.add_error(f"{path}.action",
                             f"Invalid action: '{action}'",
                             "Valid values: permit, deny")
        
        # Validate match
        if 'match' in config:
            match = config['match']
            if isinstance(match, dict):
                for prefix, prefix_config in match.items():
                    if not self._is_valid_ip_prefix(prefix):
                        self.add_error(f"{path}.match.{prefix}",
                                     f"Invalid prefix: '{prefix}'")
                    
                    if isinstance(prefix_config, dict):
                        if 'max-prefix-len' in prefix_config:
                            max_len = prefix_config['max-prefix-len']
                            if isinstance(max_len, int) and (max_len < 0 or max_len > 128):
                                self.add_error(f"{path}.match.{prefix}.max-prefix-len",
                                             f"max-prefix-len must be between 0-128: {max_len}")
    
    def _validate_route_map(self, name: str, config: Dict, path: str):
        """Validate route-map configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate rules
        if 'rule' in config:
            rules = config['rule']
            if isinstance(rules, dict):
                for rule_id, rule_config in rules.items():
                    rule_path = f"{path}.rule.{rule_id}"
                    self._validate_route_map_rule(rule_config, rule_path)
    
    def _validate_route_map_rule(self, config: Dict, path: str):
        """Validate route-map rule configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate action
        if 'action' in config:
            action = config['action']
            if isinstance(action, dict):
                for act in action.keys():
                    if act not in ['permit', 'deny']:
                        self.add_warning(f"{path}.action.{act}",
                                       f"Unknown action: '{act}'")
    
    def _validate_router_bgp(self, config: Dict, path: str):
        """Validate router BGP configuration."""
        if not isinstance(config, dict):
            return
        
        is_enabled = config.get('enable') in ['on', True]
        
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Required fields when BGP is enabled
        if is_enabled:
            if 'autonomous-system' not in config:
                self.add_error(path, 
                             "BGP is enabled but 'autonomous-system' is missing",
                             "autonomous-system: <ASN>")
            
            if 'router-id' not in config:
                self.add_error(path,
                             "BGP is enabled but 'router-id' is missing", 
                             "router-id: <IP> (typically loopback IP)")
    
    # ========================================================================
    # VRF VALIDATION
    # ========================================================================
    
    def _validate_vrfs(self, data: Dict, path: str):
        """Validate VRF configurations."""
        if not isinstance(data, dict):
            return
        
        for vrf_name, vrf_config in data.items():
            vrf_path = f"{path}.{vrf_name}"
            self._validate_vrf(vrf_name, vrf_config, vrf_path)
    
    def _validate_vrf(self, name: str, config: Dict, path: str):
        """Validate a single VRF configuration."""
        self.defined_vrfs.add(name)
        
        # Validate VRF name
        if name != 'default' and name.lower() in RESERVED_NAMES:
            self.add_error(path, f"'{name}' is a reserved name")
        
        if not isinstance(config, dict):
            return
        
        # Validate VRF EVPN settings (L3VNI)
        if 'evpn' in config:
            self._validate_vrf_evpn(config['evpn'], f"{path}.evpn", name)
        
        # Validate loopback
        if 'loopback' in config:
            loopback = config['loopback']
            if isinstance(loopback, dict) and 'ip' in loopback:
                ip_config = loopback['ip']
                if isinstance(ip_config, dict) and 'address' in ip_config:
                    addresses = ip_config['address']
                    if isinstance(addresses, dict):
                        for addr in addresses.keys():
                            if not self._is_valid_ip_prefix(addr):
                                self.add_error(f"{path}.loopback.ip.address.{addr}",
                                             f"Invalid VRF loopback IP: '{addr}'")
        
        # Validate router configuration
        if 'router' in config:
            router = config['router']
            if isinstance(router, dict):
                if 'bgp' in router:
                    self._validate_vrf_bgp(router['bgp'], f"{path}.router.bgp", name)
                
                # Validate OSPF
                if 'ospf' in router:
                    self._validate_vrf_ospf(router['ospf'], f"{path}.router.ospf", name)
                
                # Validate static routes
                if 'static' in router:
                    self._validate_static_routes(router['static'], f"{path}.router.static")
    
    def _validate_vrf_ospf(self, config: Dict, path: str, vrf_name: str):
        """Validate VRF OSPF configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate enable
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate router-id - required when enabled
        is_enabled = config.get('enable') in ['on', True]
        if is_enabled:
            if 'router-id' not in config:
                self.add_error(path,
                             f"OSPF is enabled but 'router-id' is missing for VRF '{vrf_name}'",
                             "router-id: <IP> (typically loopback IP)")
        
        if 'router-id' in config:
            router_id = config['router-id']
            if not self._is_valid_ip(router_id):
                self.add_error(f"{path}.router-id",
                             f"Invalid OSPF router-id: '{router_id}'")
        
        # Validate areas
        if 'area' in config:
            areas = config['area']
            if isinstance(areas, dict):
                for area_id, area_config in areas.items():
                    area_path = f"{path}.area.{area_id}"
                    self._validate_ospf_area(area_id, area_config, area_path)
        
        # Validate timers
        if 'timers' in config:
            timers = config['timers']
            if isinstance(timers, dict):
                if 'spf' in timers:
                    spf = timers['spf']
                    if isinstance(spf, dict):
                        for timer in ['delay', 'holdtime', 'max-holdtime']:
                            if timer in spf:
                                val = spf[timer]
                                if isinstance(val, int) and val < 0:
                                    self.add_error(f"{path}.timers.spf.{timer}",
                                                 f"SPF timer cannot be negative: {val}")
    
    def _validate_ospf_area(self, area_id: str, config: Dict, path: str):
        """Validate OSPF area configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate area ID format (can be 0, 0.0.0.0, or dotted decimal)
        if area_id != '0' and not self._is_valid_ip(area_id):
            try:
                int(area_id)
            except ValueError:
                self.add_warning(path,
                               f"OSPF area ID format should be verified: '{area_id}'",
                               "Use numeric (0) or dotted decimal (0.0.0.0)")
        
        # Validate area type
        if 'type' in config:
            area_type = config['type']
            valid_types = {'normal', 'stub', 'totally-stub', 'nssa', 'totally-nssa'}
            if area_type not in valid_types:
                self.add_error(f"{path}.type",
                             f"Invalid OSPF area type: '{area_type}'",
                             f"Valid types: {', '.join(valid_types)}")
        
        # Validate network/range
        if 'network' in config:
            networks = config['network']
            if isinstance(networks, dict):
                for network in networks.keys():
                    if not self._is_valid_ip_prefix(network):
                        self.add_error(f"{path}.network.{network}",
                                     f"Invalid OSPF network: '{network}'")
    
    def _validate_vrf_evpn(self, config: Dict, path: str, vrf_name: str):
        """Validate VRF EVPN configuration (L3VNI)."""
        if not isinstance(config, dict):
            return
        
        # Validate enable
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate L3VNI
        if 'vni' in config:
            vni_config = config['vni']
            if isinstance(vni_config, dict):
                for vni_id in vni_config.keys():
                    try:
                        vni = int(vni_id)
                        if vni < VNI_MIN or vni > VNI_MAX:
                            self.add_error(f"{path}.vni.{vni_id}",
                                         f"L3VNI must be between {VNI_MIN}-{VNI_MAX}: {vni}")
                    except ValueError:
                        self.add_error(f"{path}.vni.{vni_id}",
                                     f"VNI must be numeric: '{vni_id}'")
        else:
            # L3VNI is typically required for non-default VRF with EVPN
            if vrf_name != 'default' and 'enable' in config:
                self.add_warning(path, f"VRF '{vrf_name}' for EVPN enabled but VNI not defined",
                               "L3VNI is typically required for EVPN inter-subnet routing")
        
        # Validate VLAN mapping
        if 'vlan' in config:
            vlan = config['vlan']
            if not self._is_valid_vlan_id(vlan):
                self.add_error(f"{path}.vlan",
                             f"Invalid EVPN VLAN: {vlan}")
    
    def _validate_static_routes(self, config: Dict, path: str):
        """Validate static routes configuration."""
        if not isinstance(config, dict):
            return
        
        for route, route_config in config.items():
            route_path = f"{path}.{route}"
            
            # Validate route prefix
            if route != '0.0.0.0/0' and not self._is_valid_ip_prefix(route):
                self.add_error(route_path, f"Invalid static route: '{route}'")
            
            if not isinstance(route_config, dict):
                continue
            
            # Required: via (nexthop)
            if 'via' not in route_config:
                self.add_error(route_path,
                             f"Static route '{route}' 'via' (nexthop) is missing",
                             "via: <NEXTHOP_IP>: type: ipv4-address add")
            
            # Validate via (nexthop)
            if 'via' in route_config:
                via = route_config['via']
                if isinstance(via, dict):
                    for nexthop, nh_config in via.items():
                        if not self._is_valid_ip(nexthop) and not self._is_valid_interface_name(nexthop):
                            self.add_warning(f"{route_path}.via.{nexthop}",
                                           f"Nexthop should be verified: '{nexthop}'")
                        
                        if isinstance(nh_config, dict) and 'type' in nh_config:
                            nh_type = nh_config['type']
                            if nh_type not in ['ipv4-address', 'ipv6-address', 'interface']:
                                self.add_warning(f"{route_path}.via.{nexthop}.type",
                                               f"Unknown nexthop type: '{nh_type}'")
    
    def _validate_vrf_bgp(self, config: Dict, path: str, vrf_name: str):
        """Validate VRF BGP configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate router-id
        if 'router-id' in config:
            router_id = config['router-id']
            if not self._is_valid_ip(router_id):
                self.add_error(f"{path}.router-id",
                             f"Invalid router-id: '{router_id}'",
                             "Must be IPv4 address format (e.g. 10.0.0.1)")
        
        # Validate ASN
        if 'autonomous-system' in config:
            asn = config['autonomous-system']
            if isinstance(asn, int):
                if asn < ASN_MIN or asn > ASN_MAX:
                    self.add_error(f"{path}.autonomous-system",
                                 f"ASN must be between {ASN_MIN}-{ASN_MAX}: {asn}")
        
        # Validate RD (Route Distinguisher)
        if 'rd' in config:
            rd = config['rd']
            if not self._is_valid_rd(rd):
                self.add_error(f"{path}.rd",
                             f"Invalid Route Distinguisher: '{rd}'",
                             "Format: IP:VNI or ASN:NN (e.g. 10.0.0.1:4001)")
        
        # Validate address-family
        if 'address-family' in config:
            self._validate_bgp_address_family(config['address-family'], f"{path}.address-family", vrf_name)
        
        # Validate peer-group
        if 'peer-group' in config:
            peer_groups = config['peer-group']
            if isinstance(peer_groups, dict):
                for pg_name, pg_config in peer_groups.items():
                    self._validate_bgp_peer_group(pg_name, pg_config, f"{path}.peer-group.{pg_name}")
        
        # Validate neighbors
        if 'neighbor' in config:
            neighbors = config['neighbor']
            if isinstance(neighbors, dict):
                for neighbor_id, neighbor_config in neighbors.items():
                    neighbor_path = f"{path}.neighbor.{neighbor_id}"
                    self._validate_bgp_neighbor(neighbor_id, neighbor_config, neighbor_path)
        
        # Validate route-export
        if 'route-export' in config:
            self._validate_route_export(config['route-export'], f"{path}.route-export")
    
    def _is_valid_rd(self, rd: str) -> bool:
        """Validate Route Distinguisher format (IP:NN or ASN:NN)."""
        if not isinstance(rd, str):
            return False
        if ':' not in rd:
            return False
        parts = rd.split(':')
        if len(parts) != 2:
            return False
        # IP:NN format
        if self._is_valid_ip(parts[0]):
            try:
                int(parts[1])
                return True
            except ValueError:
                return False
        # ASN:NN format
        try:
            int(parts[0])
            int(parts[1])
            return True
        except ValueError:
            return False
    
    def _validate_bgp_address_family(self, config: Dict, path: str, vrf_name: str):
        """Validate BGP address-family configuration."""
        if not isinstance(config, dict):
            return
        
        for af_name, af_config in config.items():
            af_path = f"{path}.{af_name}"
            
            if af_name not in VALID_ADDRESS_FAMILIES:
                self.add_warning(af_path, f"Unknown address-family: '{af_name}'",
                               f"Valid values: {', '.join(VALID_ADDRESS_FAMILIES)}")
            
            if not isinstance(af_config, dict):
                continue
            
            # Validate enable
            if 'enable' in af_config:
                val = af_config['enable']
                if val not in VALID_ON_OFF and val not in [True, False]:
                    self.add_error(f"{af_path}.enable",
                                 f"Invalid value: '{val}' (must be on/off)")
            
            # Validate network prefixes
            if 'network' in af_config:
                networks = af_config['network']
                if isinstance(networks, dict):
                    for network in networks.keys():
                        if not self._is_valid_ip_prefix(network):
                            self.add_error(f"{af_path}.network.{network}",
                                         f"Invalid network prefix: '{network}'")
            
            # Validate aggregate-route
            if 'aggregate-route' in af_config:
                agg_routes = af_config['aggregate-route']
                if isinstance(agg_routes, dict):
                    for route in agg_routes.keys():
                        if not self._is_valid_ip_prefix(route):
                            self.add_error(f"{af_path}.aggregate-route.{route}",
                                         f"Invalid aggregate route: '{route}'")
            
            # Validate route-export
            if 'route-export' in af_config:
                self._validate_route_export(af_config['route-export'], f"{af_path}.route-export")
            
            # Validate route-import
            if 'route-import' in af_config:
                self._validate_route_import(af_config['route-import'], f"{af_path}.route-import")
    
    def _validate_route_export(self, config: Dict, path: str):
        """Validate route-export configuration."""
        if not isinstance(config, dict):
            return
        
        if 'to-evpn' in config:
            to_evpn = config['to-evpn']
            if isinstance(to_evpn, dict):
                if 'enable' in to_evpn:
                    val = to_evpn['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.to-evpn.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                # Validate route-target
                if 'route-target' in to_evpn:
                    rt = to_evpn['route-target']
                    if isinstance(rt, dict):
                        for rt_value in rt.keys():
                            if not self._is_valid_rd(rt_value):
                                self.add_warning(f"{path}.to-evpn.route-target.{rt_value}",
                                               f"Route target format should be verified: '{rt_value}'")
    
    def _validate_route_import(self, config: Dict, path: str):
        """Validate route-import configuration."""
        if not isinstance(config, dict):
            return
        
        if 'from-vrf' in config:
            from_vrf = config['from-vrf']
            if isinstance(from_vrf, dict):
                if 'list' in from_vrf:
                    vrf_list = from_vrf['list']
                    if isinstance(vrf_list, dict):
                        for vrf_name in vrf_list.keys():
                            if vrf_name.lower() in RESERVED_NAMES:
                                self.add_error(f"{path}.from-vrf.list.{vrf_name}",
                                             f"'{vrf_name}' is a reserved name")
    
    def _validate_bgp_peer_group(self, name: str, config: Dict, path: str):
        """Validate BGP peer-group configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate remote-as
        if 'remote-as' in config:
            remote_as = config['remote-as']
            if remote_as not in VALID_BGP_PEER_TYPES:
                if isinstance(remote_as, int):
                    if remote_as < ASN_MIN or remote_as > ASN_MAX:
                        self.add_error(f"{path}.remote-as",
                                     f"Invalid remote-as: {remote_as}")
                else:
                    self.add_warning(f"{path}.remote-as",
                                   f"remote-as value should be verified: '{remote_as}'",
                                   "Must be 'external', 'internal', or ASN number")
        
        # Validate update-source
        if 'update-source' in config:
            source = config['update-source']
            if source != 'lo' and not self._is_valid_interface_name(source):
                self.add_warning(f"{path}.update-source",
                               f"update-source should be verified: '{source}'",
                               "Usually 'lo' is used")
        
        # Validate multihop-ttl
        if 'multihop-ttl' in config:
            ttl = config['multihop-ttl']
            if isinstance(ttl, int):
                if ttl < 1 or ttl > 255:
                    self.add_error(f"{path}.multihop-ttl",
                                 f"multihop-ttl must be between 1-255: {ttl}")
        
        # Validate BFD
        if 'bfd' in config:
            bfd = config['bfd']
            if isinstance(bfd, dict):
                if 'enable' in bfd:
                    val = bfd['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.bfd.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                # Validate BFD timers
                for timer in ['min-rx-interval', 'min-tx-interval']:
                    if timer in bfd:
                        val = bfd[timer]
                        if isinstance(val, int) and (val < 50 or val > 60000):
                            self.add_warning(f"{path}.bfd.{timer}",
                                           f"BFD timer value unusual: {val}ms")
                
                if 'detect-multiplier' in bfd:
                    val = bfd['detect-multiplier']
                    if isinstance(val, int) and (val < 2 or val > 255):
                        self.add_error(f"{path}.bfd.detect-multiplier",
                                     f"detect-multiplier must be between 2-255: {val}")
        
        # Validate address-family in peer-group
        if 'address-family' in config:
            self._validate_peer_group_address_family(config['address-family'], f"{path}.address-family")
        
        # Validate timers
        if 'timers' in config:
            timers = config['timers']
            if isinstance(timers, dict):
                if 'keepalive' in timers:
                    ka = timers['keepalive']
                    if isinstance(ka, int) and (ka < 0 or ka > 65535):
                        self.add_error(f"{path}.timers.keepalive",
                                     f"keepalive must be between 0-65535: {ka}")
                if 'hold' in timers:
                    hold = timers['hold']
                    if isinstance(hold, int) and (hold < 0 or hold > 65535):
                        self.add_error(f"{path}.timers.hold",
                                     f"hold must be between 0-65535: {hold}")
    
    def _validate_peer_group_address_family(self, config: Dict, path: str):
        """Validate peer-group address-family configuration."""
        if not isinstance(config, dict):
            return
        
        for af_name, af_config in config.items():
            af_path = f"{path}.{af_name}"
            
            if af_name not in VALID_ADDRESS_FAMILIES:
                self.add_warning(af_path, f"Unknown address-family: '{af_name}'")
            
            if not isinstance(af_config, dict):
                continue
            
            if 'enable' in af_config:
                val = af_config['enable']
                if val not in VALID_ON_OFF and val not in [True, False]:
                    self.add_error(f"{af_path}.enable",
                                 f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_bgp_neighbor(self, neighbor_id: str, config: Dict, path: str):
        """Validate BGP neighbor configuration."""
        is_ip = self._is_valid_ip(neighbor_id)
        is_interface = self._is_valid_interface_name(neighbor_id)
        
        # Neighbor ID can be IP or interface name
        if not is_ip and not is_interface:
            self.add_warning(path, f"BGP neighbor ID suspicious: '{neighbor_id}'",
                           "Must be IP address or interface name")
        
        if not isinstance(config, dict):
            return
        
        # Validate type matches neighbor_id format
        if 'type' in config:
            neighbor_type = config['type']
            if neighbor_type not in VALID_BGP_NEIGHBOR_TYPES:
                self.add_error(f"{path}.type",
                             f"Invalid neighbor type: '{neighbor_type}'",
                             f"Valid values: {', '.join(VALID_BGP_NEIGHBOR_TYPES)}")
            elif neighbor_type == 'numbered' and not is_ip:
                self.add_warning(f"{path}.type",
                               f"type: numbered but neighbor is not an IP address: '{neighbor_id}'",
                               "numbered for IP address should be used")
            elif neighbor_type == 'unnumbered' and is_ip:
                self.add_warning(f"{path}.type",
                               f"type: unnumbered but neighbor is an IP address: '{neighbor_id}'",
                               "unnumbered for interface name should be used (swp1, peerlink.4094, etc.)")
        
        # Validate remote-as
        if 'remote-as' in config:
            remote_as = config['remote-as']
            if remote_as not in VALID_BGP_PEER_TYPES:
                if isinstance(remote_as, int):
                    if remote_as < ASN_MIN or remote_as > ASN_MAX:
                        self.add_error(f"{path}.remote-as",
                                     f"remote-as invalid: {remote_as}")
                else:
                    self.add_warning(f"{path}.remote-as",
                                   f"remote-as value should be verified: '{remote_as}'")
        
        # Validate peer-group reference
        if 'peer-group' in config:
            pg = config['peer-group']
            if not isinstance(pg, str) or not pg:
                self.add_error(f"{path}.peer-group",
                             "peer-group must be a valid name")
        
        # Required: either peer-group or remote-as
        if 'peer-group' not in config and 'remote-as' not in config:
            self.add_error(path,
                         f"BGP neighbor '{neighbor_id}' requires 'peer-group' or 'remote-as'",
                         "peer-group: <GROUP_NAME> or remote-as: external/internal/<ASN>")
        
        # Validate address-family
        if 'address-family' in config:
            self._validate_peer_group_address_family(config['address-family'], f"{path}.address-family")
    
    # ========================================================================
    # SERVICE VALIDATION
    # ========================================================================
    
    def _validate_service(self, data: Dict, path: str):
        """Validate service configuration."""
        if not isinstance(data, dict):
            return
        
        if 'dns' in data:
            self._validate_dns(data['dns'], f"{path}.dns")
        
        if 'ntp' in data:
            self._validate_ntp(data['ntp'], f"{path}.ntp")
        
        if 'dhcp-relay' in data:
            self._validate_dhcp_relay(data['dhcp-relay'], f"{path}.dhcp-relay")
        
        if 'telemetry' in data:
            self._validate_telemetry(data['telemetry'], f"{path}.telemetry")
    
    def _validate_dns(self, config: Dict, path: str):
        """Validate DNS configuration."""
        if not isinstance(config, dict):
            return
        
        # DNS config is per-VRF (mgmt or default)
        for vrf_name, vrf_config in config.items():
            vrf_path = f"{path}.{vrf_name}"
            
            if not isinstance(vrf_config, dict):
                continue
            
            # Required: server
            if 'server' not in vrf_config:
                self.add_error(vrf_path,
                             f"DNS VRF '{vrf_name}' 'server' is missing",
                             "server: <IP>: {} add")
            
            # Validate server IPs
            if 'server' in vrf_config:
                servers = vrf_config['server']
                if isinstance(servers, dict):
                    for server_ip in servers.keys():
                        if not self._is_valid_ip(server_ip):
                            self.add_error(f"{vrf_path}.server.{server_ip}",
                                         f"Invalid DNS server IP: '{server_ip}'")
    
    def _validate_ntp(self, config: Dict, path: str):
        """Validate NTP configuration."""
        if not isinstance(config, dict):
            return
        
        # NTP config is per-VRF (mgmt or default)
        for vrf_name, vrf_config in config.items():
            vrf_path = f"{path}.{vrf_name}"
            
            if not isinstance(vrf_config, dict):
                continue
            
            # Required: server
            if 'server' not in vrf_config:
                self.add_error(vrf_path,
                             f"NTP VRF '{vrf_name}' 'server' is missing",
                             "server: <IP_OR_HOSTNAME>: iburst: on add")
            
            # Validate server IPs/hostnames
            if 'server' in vrf_config:
                servers = vrf_config['server']
                if isinstance(servers, dict):
                    for server in servers.keys():
                        # Can be IP or hostname
                        if not self._is_valid_ip(server) and not self._is_valid_hostname(server):
                            self.add_warning(f"{vrf_path}.server.{server}",
                                           f"NTP server value should be verified: '{server}'")
    
    def _is_valid_hostname(self, hostname: str) -> bool:
        """Check if hostname is valid."""
        if len(hostname) > 255:
            return False
        pattern = re.compile(r'^[a-zA-Z0-9]([a-zA-Z0-9\-\.]*[a-zA-Z0-9])?$')
        return bool(pattern.match(hostname))
    
    def _validate_dhcp_relay(self, config: Dict, path: str):
        """Validate DHCP relay configuration."""
        if not isinstance(config, dict):
            return
        
        # DHCP relay is per-VRF
        for vrf_name, vrf_config in config.items():
            vrf_path = f"{path}.{vrf_name}"
            
            if not isinstance(vrf_config, dict):
                continue
            
            # Validate downstream-interface
            if 'downstream-interface' in vrf_config:
                downstream = vrf_config['downstream-interface']
                if isinstance(downstream, dict):
                    for iface in downstream.keys():
                        if not self._is_valid_interface_name(iface):
                            self.add_warning(f"{vrf_path}.downstream-interface.{iface}",
                                           f"Interface name should be verified: '{iface}'")
            
            # Required: downstream-interface
            if 'downstream-interface' not in vrf_config:
                self.add_error(vrf_path,
                             f"DHCP relay VRF '{vrf_name}' 'downstream-interface' is missing",
                             "downstream-interface: <INTERFACE>: server-group-name: servers add")
            
            # Validate server-group
            if 'server-group' in vrf_config:
                sg = vrf_config['server-group']
                if isinstance(sg, dict):
                    for sg_name, sg_config in sg.items():
                        sg_path = f"{vrf_path}.server-group.{sg_name}"
                        
                        if isinstance(sg_config, dict):
                            # Required: server in server-group
                            if 'server' not in sg_config:
                                self.add_error(sg_path,
                                             f"Server-group '{sg_name}' 'server' is missing",
                                             "server: <IP>: {} add")
                            
                            if 'server' in sg_config:
                                servers = sg_config['server']
                                if isinstance(servers, dict):
                                    for server_ip in servers.keys():
                                        if not self._is_valid_ip(server_ip):
                                            self.add_error(f"{sg_path}.server.{server_ip}",
                                                         f"Invalid DHCP server IP: '{server_ip}'")
    
    def _validate_telemetry(self, config: Dict, path: str):
        """Validate telemetry configuration."""
        if not isinstance(config, dict):
            return
        
        # Validate enable
        if 'enable' in config:
            val = config['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate histogram settings
        if 'histogram' in config:
            histogram = config['histogram']
            if isinstance(histogram, dict):
                for buffer_type in ['egress-buffer', 'ingress-buffer', 'counter']:
                    if buffer_type in histogram:
                        buf_config = histogram[buffer_type]
                        if isinstance(buf_config, dict):
                            buf_path = f"{path}.histogram.{buffer_type}"
                            
                            if 'sample-interval' in buf_config:
                                interval = buf_config['sample-interval']
                                if isinstance(interval, int) and interval < 1:
                                    self.add_error(f"{buf_path}.sample-interval",
                                                 f"sample-interval must be positive: {interval}")
                            
                            if 'histogram-size' in buf_config:
                                size = buf_config['histogram-size']
                                if isinstance(size, int) and size < 1:
                                    self.add_error(f"{buf_path}.histogram-size",
                                                 f"histogram-size must be positive: {size}")
    
    # ========================================================================
    # EVPN VALIDATION
    # ========================================================================
    
    def _validate_evpn(self, data: Dict, path: str):
        """Validate EVPN configuration."""
        if not isinstance(data, dict):
            return
        
        if 'enable' in data:
            val = data['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
    
    def _validate_nve(self, data: Dict, path: str):
        """Validate NVE (VXLAN) configuration."""
        if not isinstance(data, dict):
            return
        
        if 'vxlan' in data:
            vxlan = data['vxlan']
            if isinstance(vxlan, dict):
                # Validate enable
                if 'enable' in vxlan:
                    val = vxlan['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.vxlan.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                is_vxlan_enabled = vxlan.get('enable') in ['on', True]
                
                # Validate source address (VTEP IP) - REQUIRED when enabled
                if 'source' in vxlan:
                    source = vxlan['source']
                    if isinstance(source, dict) and 'address' in source:
                        addr = source['address']
                        if not self._is_valid_ip(addr):
                            self.add_error(f"{path}.vxlan.source.address",
                                         f"Invalid VTEP source IP: '{addr}'",
                                         "Usually loopback IP address is used")
                    elif isinstance(source, dict) and 'address' not in source:
                        if is_vxlan_enabled:
                            self.add_error(f"{path}.vxlan.source",
                                         "VXLAN 'source' is defined but 'address' is missing",
                                         "source: address: <LOOPBACK_IP> add")
                else:
                    if is_vxlan_enabled:
                        self.add_error(f"{path}.vxlan",
                                     "VXLAN is enabled but 'source.address' is missing",
                                     "source: address: <LOOPBACK_IP> add")
                
                # Validate MLAG shared address (anycast VTEP)
                if 'mlag' in vxlan:
                    mlag = vxlan['mlag']
                    if isinstance(mlag, dict) and 'shared-address' in mlag:
                        addr = mlag['shared-address']
                        if not self._is_valid_ip(addr):
                            self.add_error(f"{path}.vxlan.mlag.shared-address",
                                         f"Invalid MLAG anycast VTEP IP: '{addr}'")
                
                # Validate arp-nd-suppress
                if 'arp-nd-suppress' in vxlan:
                    val = vxlan['arp-nd-suppress']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.vxlan.arp-nd-suppress",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                # Validate encapsulation/decapsulation DSCP
                for direction in ['encapsulation', 'decapsulation']:
                    if direction in vxlan:
                        dir_config = vxlan[direction]
                        if isinstance(dir_config, dict) and 'dscp' in dir_config:
                            dscp = dir_config['dscp']
                            if isinstance(dscp, dict) and 'action' in dscp:
                                action = dscp['action']
                                valid_actions = {'preserve', 'copy', 'derive'}
                                if action not in valid_actions:
                                    self.add_warning(f"{path}.vxlan.{direction}.dscp.action",
                                                   f"Unknown DSCP action: '{action}'",
                                                   f"Valid values: {', '.join(valid_actions)}")
    
    # ========================================================================
    # QOS VALIDATION
    # ========================================================================
    
    def _validate_qos(self, data: Dict, path: str):
        """Validate QoS configuration."""
        if not isinstance(data, dict):
            return
        
        # Validate RoCE
        if 'roce' in data:
            roce = data['roce']
            if isinstance(roce, dict):
                if 'enable' in roce:
                    val = roce['enable']
                    if val not in VALID_ON_OFF and val not in [True, False]:
                        self.add_error(f"{path}.roce.enable",
                                     f"Invalid value: '{val}' (must be on/off)")
                
                if 'mode' in roce:
                    mode = roce['mode']
                    if mode not in ['lossless', 'lossy']:
                        self.add_error(f"{path}.roce.mode",
                                     f"Invalid RoCE mode: '{mode}' (must be lossless or lossy)")
        
        # Validate PFC
        if 'pfc' in data:
            pfc = data['pfc']
            if isinstance(pfc, dict):
                for profile_name, profile_config in pfc.items():
                    pfc_path = f"{path}.pfc.{profile_name}"
                    if isinstance(profile_config, dict):
                        # Validate port-buffer
                        if 'port-buffer' in profile_config:
                            pb = profile_config['port-buffer']
                            if isinstance(pb, int) and pb < 0:
                                self.add_error(f"{pfc_path}.port-buffer",
                                             f"port-buffer cannot be negative: {pb}")
                        
                        # Validate switch-priority
                        if 'switch-priority' in profile_config:
                            sp = profile_config['switch-priority']
                            if isinstance(sp, dict):
                                for priority in sp.keys():
                                    try:
                                        p = int(priority)
                                        if p < 0 or p > 7:
                                            self.add_error(f"{pfc_path}.switch-priority.{priority}",
                                                         "switch-priority must be between 0-7")
                                    except ValueError:
                                        self.add_error(f"{pfc_path}.switch-priority.{priority}",
                                                     "switch-priority must be numeric")
        
        # Validate traffic-pool
        if 'traffic-pool' in data:
            pools = data['traffic-pool']
            if isinstance(pools, dict):
                for pool_name, pool_config in pools.items():
                    pool_path = f"{path}.traffic-pool.{pool_name}"
                    if isinstance(pool_config, dict):
                        if 'memory-percent' in pool_config:
                            mp = pool_config['memory-percent']
                            if isinstance(mp, int) and (mp < 0 or mp > 100):
                                self.add_error(f"{pool_path}.memory-percent",
                                             f"memory-percent must be between 0-100: {mp}")
    
    # ========================================================================
    # ACL VALIDATION
    # ========================================================================
    
    def _validate_acl(self, data: Dict, path: str):
        """Validate ACL configuration."""
        if not isinstance(data, dict):
            return
        
        # ACL mode (if this is top-level acl config like acl.mode)
        if 'mode' in data:
            mode = data['mode']
            if mode not in ['atomic', 'non-atomic']:
                self.add_warning(f"{path}.mode",
                               f"Unknown ACL mode: '{mode}'")
        
        # Individual ACL validation
        for acl_name, acl_config in data.items():
            if acl_name in ['mode']:
                continue
            
            acl_path = f"{path}.{acl_name}"
            
            if not isinstance(acl_config, dict):
                continue
            
            # Validate type
            if 'type' in acl_config:
                acl_type = acl_config['type']
                if acl_type not in ['ipv4', 'ipv6', 'mac']:
                    self.add_error(f"{acl_path}.type",
                                 f"Invalid ACL type: '{acl_type}'",
                                 "Valid values: ipv4, ipv6, mac")
            
            # Validate rules
            if 'rule' in acl_config:
                rules = acl_config['rule']
                if isinstance(rules, dict):
                    for rule_id, rule_config in rules.items():
                        rule_path = f"{acl_path}.rule.{rule_id}"
                        self._validate_acl_rule(rule_config, rule_path)
    
    def _validate_acl_rule(self, config: Dict, path: str):
        """Validate ACL rule configuration."""
        if not isinstance(config, dict):
            return
        
        # Required: action
        if 'action' not in config:
            self.add_error(path,
                         "ACL rule 'action' is missing",
                         "action: permit: {} or action: deny: {} add")
        
        # Validate action
        if 'action' in config:
            action = config['action']
            if isinstance(action, dict):
                valid_actions = {'permit', 'deny', 'log'}
                for act in action.keys():
                    if act not in valid_actions:
                        self.add_warning(f"{path}.action.{act}",
                                       f"Unknown ACL action: '{act}'")
        
        # Validate match
        if 'match' in config:
            match = config['match']
            if isinstance(match, dict):
                if 'ip' in match:
                    ip_match = match['ip']
                    if isinstance(ip_match, dict):
                        # Validate source-ip
                        if 'source-ip' in ip_match:
                            src = ip_match['source-ip']
                            if src != 'any' and not self._is_valid_ip_prefix(src) and not self._is_valid_ip(src):
                                self.add_error(f"{path}.match.ip.source-ip",
                                             f"Invalid source-ip: '{src}'")
                        
                        # Validate dest-ip
                        if 'dest-ip' in ip_match:
                            dst = ip_match['dest-ip']
                            if dst != 'any' and not self._is_valid_ip_prefix(dst) and not self._is_valid_ip(dst):
                                self.add_error(f"{path}.match.ip.dest-ip",
                                             f"Invalid dest-ip: '{dst}'")
                        
                        # Validate TCP settings
                        if 'tcp' in ip_match:
                            tcp = ip_match['tcp']
                            if isinstance(tcp, dict):
                                for port_type in ['source-port', 'dest-port']:
                                    if port_type in tcp:
                                        ports = tcp[port_type]
                                        if isinstance(ports, dict):
                                            for port in ports.keys():
                                                try:
                                                    p = int(port)
                                                    if p < 0 or p > 65535:
                                                        self.add_error(f"{path}.match.ip.tcp.{port_type}.{port}",
                                                                     "Port must be between 0-65535")
                                                except ValueError:
                                                    # Could be a range or service name
                                                    pass
                        
                        # Validate UDP settings
                        if 'udp' in ip_match:
                            udp = ip_match['udp']
                            if isinstance(udp, dict):
                                for port_type in ['source-port', 'dest-port']:
                                    if port_type in udp:
                                        ports = udp[port_type]
                                        if isinstance(ports, dict):
                                            for port in ports.keys():
                                                try:
                                                    p = int(port)
                                                    if p < 0 or p > 65535:
                                                        self.add_error(f"{path}.match.ip.udp.{port_type}.{port}",
                                                                     "Port must be between 0-65535")
                                                except ValueError:
                                                    pass
    
    # ========================================================================
    # GLOBAL VALIDATION
    # ========================================================================
    
    def _validate_global(self, data: Dict, path: str):
        """Validate global configuration."""
        if not isinstance(data, dict):
            return
        
        # Fabric MAC validation
        if 'fabric-mac' in data:
            mac = data['fabric-mac']
            if not self._is_valid_mac(mac):
                self.add_error(f"{path}.fabric-mac",
                             f"Invalid fabric MAC: '{mac}'")
    
    def _validate_lldp(self, data: Dict, path: str):
        """Validate LLDP configuration."""
        if not isinstance(data, dict):
            return
        
        # Validate enable (global)
        if 'enable' in data:
            val = data['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate tx-interval (5-32768 seconds)
        if 'tx-interval' in data:
            interval = data['tx-interval']
            if isinstance(interval, int):
                if interval < 5 or interval > 32768:
                    self.add_error(f"{path}.tx-interval",
                                 f"tx-interval must be between 5-32768 seconds: {interval}")
        
        # Validate tx-hold-multiplier (1-8192)
        if 'tx-hold-multiplier' in data:
            multiplier = data['tx-hold-multiplier']
            if isinstance(multiplier, int):
                if multiplier < 1 or multiplier > 8192:
                    self.add_error(f"{path}.tx-hold-multiplier",
                                 f"tx-hold-multiplier must be between 1-8192: {multiplier}")
        
        # Validate dot1-tlv (IEEE 802.1 TLVs)
        if 'dot1-tlv' in data:
            val = data['dot1-tlv']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.dot1-tlv",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Validate mode
        if 'mode' in data:
            mode = data['mode']
            valid_modes = {'default', 'cdpv1', 'cdpv2', 'lldp'}
            if mode not in valid_modes:
                self.add_warning(f"{path}.mode",
                               f"Unknown LLDP mode: '{mode}'",
                               f"Valid modes: {', '.join(valid_modes)}")
    
    def _validate_mlag(self, data: Dict, path: str):
        """Validate MLAG configuration."""
        if not isinstance(data, dict):
            return
        
        is_enabled = data.get('enable') in ['on', True]
        
        # Validate enable
        if 'enable' in data:
            val = data['enable']
            if val not in VALID_ON_OFF and val not in [True, False]:
                self.add_error(f"{path}.enable",
                             f"Invalid value: '{val}' (must be on/off)")
        
        # Required fields when MLAG is enabled
        if is_enabled:
            if 'mac-address' not in data:
                self.add_error(path,
                             "MLAG is enabled but 'mac-address' is missing",
                             "mac-address: XX:XX:XX:XX:XX:XX (system MAC)")
            
            if 'peer-ip' not in data:
                self.add_error(path,
                             "MLAG is enabled but 'peer-ip' is missing",
                             "peer-ip: linklocal or peer-ip: <IP>")
        
        # Validate MAC address
        if 'mac-address' in data:
            mac = data['mac-address']
            if not self._is_valid_mac(mac):
                self.add_error(f"{path}.mac-address",
                             f"Invalid MLAG system MAC: '{mac}'")
        
        # Validate peer-ip
        if 'peer-ip' in data:
            peer_ip = data['peer-ip']
            if peer_ip != 'linklocal' and not self._is_valid_ip(peer_ip):
                self.add_error(f"{path}.peer-ip",
                             f"Invalid peer-ip: '{peer_ip}'",
                             "Must be 'linklocal' or IPv4 address")
        
        # Validate backup
        if 'backup' in data:
            backup = data['backup']
            if isinstance(backup, dict):
                for backup_ip, backup_config in backup.items():
                    if not self._is_valid_ip(backup_ip):
                        self.add_error(f"{path}.backup.{backup_ip}",
                                     f"Invalid backup IP: '{backup_ip}'")
                    
                    if isinstance(backup_config, dict) and 'vrf' in backup_config:
                        vrf = backup_config['vrf']
                        if vrf.lower() in RESERVED_NAMES and vrf not in ['mgmt', 'default']:
                            self.add_warning(f"{path}.backup.{backup_ip}.vrf",
                                           f"VRF should be verified: '{vrf}'")
        
        # Validate priority
        if 'priority' in data:
            priority = data['priority']
            if isinstance(priority, int):
                if priority < 0 or priority > 65535:
                    self.add_error(f"{path}.priority",
                                 f"MLAG priority must be between 0-65535: {priority}")
        
        # Validate init-delay
        if 'init-delay' in data:
            delay = data['init-delay']
            if isinstance(delay, int) and delay < 0:
                self.add_error(f"{path}.init-delay",
                             f"init-delay cannot be negative: {delay}")


# ============================================================================
# TOPOLOGY ANALYZER (Cross-Device Analysis)
# ============================================================================

@dataclass
class TopologyIssue:
    """Represents a topology-level issue."""
    severity: Severity
    category: str
    message: str
    devices: List[str]
    suggestion: Optional[str] = None
    details: Optional[List[str]] = None  # Additional detail lines

    def __str__(self):
        devices_str = ", ".join(self.devices)
        result = f"[{self.severity.value}] {self.category}: {self.message} (Devices: {devices_str})"
        if self.suggestion:
            result += f"\n         -> Suggestion: {self.suggestion}"
        return result


@dataclass
class TopologyReport:
    """Complete topology analysis report."""
    devices: Dict[str, Dict] = field(default_factory=dict)
    issues: List[TopologyIssue] = field(default_factory=list)
    
    # Collected data for reporting
    loopback_ips: Dict[str, List[str]] = field(default_factory=dict)  # IP -> [devices]
    system_macs: Dict[str, List[str]] = field(default_factory=dict)   # MAC -> [devices]
    mlag_macs: Dict[str, List[str]] = field(default_factory=dict)     # MAC -> [devices]
    vtep_ips: Dict[str, List[str]] = field(default_factory=dict)      # IP -> [devices]
    vlan_vni_map: Dict[str, Dict[int, int]] = field(default_factory=dict)  # device -> {vlan: vni}
    vrf_l3vni_map: Dict[str, Dict[str, int]] = field(default_factory=dict)  # device -> {vrf: l3vni}
    vrf_asn_map: Dict[str, Dict[str, int]] = field(default_factory=dict)    # device -> {vrf: asn}
    
    @property
    def error_count(self) -> int:
        return sum(1 for i in self.issues if i.severity == Severity.ERROR)
    
    @property
    def warning_count(self) -> int:
        return sum(1 for i in self.issues if i.severity == Severity.WARNING)


class TopologyAnalyzer:
    """Analyzes topology-level consistency across multiple devices."""
    
    def __init__(self):
        self.report = TopologyReport()
    
    def add_device(self, device_name: str, yaml_content: Any):
        """Extract relevant data from a device configuration."""
        if not isinstance(yaml_content, list):
            return
        
        device_data = {
            'loopback_ips': [],
            'system_mac': None,
            'mlag_mac': None,
            'vtep_ip': None,
            'vlan_vni': {},
            'vrf_l3vni': {},
            'vrf_asn': {},
        }
        
        for item in yaml_content:
            if not isinstance(item, dict) or 'set' not in item:
                continue
            
            data = item['set']
            if not isinstance(data, dict):
                continue
            
            # Extract loopback IPs
            if 'interface' in data:
                self._extract_loopback_ips(data['interface'], device_data)
            
            # Extract system/MLAG MAC
            if 'system' in data:
                self._extract_system_mac(data['system'], device_data)
            
            if 'mlag' in data:
                self._extract_mlag_mac(data['mlag'], device_data)
            
            # Extract VTEP IP
            if 'nve' in data:
                self._extract_vtep_ip(data['nve'], device_data)
            
            # Extract VLAN-VNI mappings
            if 'bridge' in data:
                self._extract_vlan_vni(data['bridge'], device_data)
            
            # Extract VRF L3VNI and ASN
            if 'vrf' in data:
                self._extract_vrf_data(data['vrf'], device_data)
        
        self.report.devices[device_name] = device_data
        
        # Aggregate data for cross-device analysis
        for ip in device_data['loopback_ips']:
            if ip not in self.report.loopback_ips:
                self.report.loopback_ips[ip] = []
            self.report.loopback_ips[ip].append(device_name)
        
        if device_data['system_mac']:
            mac = device_data['system_mac']
            if mac not in self.report.system_macs:
                self.report.system_macs[mac] = []
            self.report.system_macs[mac].append(device_name)
        
        if device_data['mlag_mac']:
            mac = device_data['mlag_mac']
            if mac not in self.report.mlag_macs:
                self.report.mlag_macs[mac] = []
            self.report.mlag_macs[mac].append(device_name)
        
        if device_data['vtep_ip']:
            ip = device_data['vtep_ip']
            if ip not in self.report.vtep_ips:
                self.report.vtep_ips[ip] = []
            self.report.vtep_ips[ip].append(device_name)
        
        self.report.vlan_vni_map[device_name] = device_data['vlan_vni']
        self.report.vrf_l3vni_map[device_name] = device_data['vrf_l3vni']
        self.report.vrf_asn_map[device_name] = device_data['vrf_asn']
    
    def _extract_loopback_ips(self, interfaces: Dict, device_data: Dict):
        """Extract loopback IP addresses."""
        if not isinstance(interfaces, dict):
            return
        
        for iface_name, iface_config in interfaces.items():
            if iface_name == 'lo' or (isinstance(iface_config, dict) and iface_config.get('type') == 'loopback'):
                if isinstance(iface_config, dict) and 'ip' in iface_config:
                    ip_config = iface_config['ip']
                    if isinstance(ip_config, dict) and 'address' in ip_config:
                        addresses = ip_config['address']
                        if isinstance(addresses, dict):
                            for addr in addresses.keys():
                                # Extract IP without prefix
                                ip = addr.split('/')[0]
                                device_data['loopback_ips'].append(ip)
    
    def _extract_system_mac(self, system: Dict, device_data: Dict):
        """Extract system MAC address."""
        if isinstance(system, dict) and 'global' in system:
            glob = system['global']
            if isinstance(glob, dict) and 'system-mac' in glob:
                device_data['system_mac'] = glob['system-mac']
    
    def _extract_mlag_mac(self, mlag: Dict, device_data: Dict):
        """Extract MLAG system MAC."""
        if isinstance(mlag, dict) and 'mac-address' in mlag:
            device_data['mlag_mac'] = mlag['mac-address']
    
    def _extract_vtep_ip(self, nve: Dict, device_data: Dict):
        """Extract VTEP source IP."""
        if not isinstance(nve, dict):
            return
        
        if 'vxlan' in nve:
            vxlan = nve['vxlan']
            if isinstance(vxlan, dict) and 'source' in vxlan:
                source = vxlan['source']
                if isinstance(source, dict) and 'address' in source:
                    device_data['vtep_ip'] = source['address']
    
    def _extract_vlan_vni(self, bridge: Dict, device_data: Dict):
        """Extract VLAN to VNI mappings."""
        if not isinstance(bridge, dict) or 'domain' not in bridge:
            return
        
        domains = bridge['domain']
        if not isinstance(domains, dict):
            return
        
        for domain_name, domain_config in domains.items():
            if not isinstance(domain_config, dict) or 'vlan' not in domain_config:
                continue
            
            vlans = domain_config['vlan']
            if not isinstance(vlans, dict):
                continue
            
            for vlan_id, vlan_config in vlans.items():
                if not isinstance(vlan_config, dict) or 'vni' not in vlan_config:
                    continue
                
                vni_config = vlan_config['vni']
                if isinstance(vni_config, dict):
                    for vni_id in vni_config.keys():
                        try:
                            device_data['vlan_vni'][int(vlan_id)] = int(vni_id)
                        except ValueError:
                            pass
    
    def _extract_vrf_data(self, vrfs: Dict, device_data: Dict):
        """Extract VRF L3VNI and ASN data."""
        if not isinstance(vrfs, dict):
            return
        
        for vrf_name, vrf_config in vrfs.items():
            if not isinstance(vrf_config, dict):
                continue
            
            # Extract L3VNI
            if 'evpn' in vrf_config:
                evpn = vrf_config['evpn']
                if isinstance(evpn, dict) and 'vni' in evpn:
                    vni_config = evpn['vni']
                    if isinstance(vni_config, dict):
                        for vni_id in vni_config.keys():
                            try:
                                device_data['vrf_l3vni'][vrf_name] = int(vni_id)
                            except ValueError:
                                pass
            
            # Extract ASN
            if 'router' in vrf_config:
                router = vrf_config['router']
                if isinstance(router, dict) and 'bgp' in router:
                    bgp = router['bgp']
                    if isinstance(bgp, dict) and 'autonomous-system' in bgp:
                        device_data['vrf_asn'][vrf_name] = bgp['autonomous-system']
    
    def analyze(self, strict: bool = False) -> TopologyReport:
        """Perform cross-device topology analysis.
        
        Args:
            strict: If True, also check VLAN-VNI consistency across all devices.
                    This may produce false positives in multi-fabric environments.
        """
        self._check_loopback_conflicts()
        self._check_system_mac_conflicts()
        self._check_mlag_mac_consistency()
        self._check_vtep_ip_conflicts()
        self._check_vrf_asn_consistency()
        self._check_vrf_l3vni_consistency()
        
        # VLAN-VNI check only in strict mode (can be intentionally different across fabrics)
        if strict:
            self._check_vlan_vni_consistency()
        
        return self.report
    
    def _check_loopback_conflicts(self):
        """Check for duplicate loopback IPs."""
        for ip, devices in self.report.loopback_ips.items():
            if len(devices) > 1:
                self.report.issues.append(TopologyIssue(
                    severity=Severity.ERROR,
                    category="Loopback IP Conflict",
                    message=f"Same loopback IP '{ip}' used on multiple devices",
                    devices=devices,
                    suggestion="Each device must have a unique loopback IP"
                ))
    
    def _check_system_mac_conflicts(self):
        """Check for duplicate system MACs (excluding MLAG pairs)."""
        for mac, devices in self.report.system_macs.items():
            if len(devices) > 1:
                # Check if these are MLAG peers (they share MLAG MAC)
                mlag_peers = self.report.mlag_macs.get(mac, [])
                if set(devices) != set(mlag_peers):
                    self.report.issues.append(TopologyIssue(
                        severity=Severity.ERROR,
                        category="System MAC Conflict",
                        message=f"Same system MAC '{mac}' used on non-MLAG devices",
                        devices=devices,
                        suggestion="Only MLAG peers should share MAC addresses"
                    ))
    
    def _check_mlag_mac_consistency(self):
        """Check MLAG MAC configuration consistency."""
        for mac, devices in self.report.mlag_macs.items():
            if len(devices) == 1:
                self.report.issues.append(TopologyIssue(
                    severity=Severity.WARNING,
                    category="MLAG Configuration",
                    message=f"MLAG MAC '{mac}' configured on only one device",
                    devices=devices,
                    suggestion="MLAG requires two peers with matching MAC"
                ))
            elif len(devices) > 2:
                self.report.issues.append(TopologyIssue(
                    severity=Severity.ERROR,
                    category="MLAG MAC Conflict",
                    message=f"Same MLAG MAC '{mac}' used on more than 2 devices",
                    devices=devices,
                    suggestion="MLAG MAC should only be shared by exactly 2 peers"
                ))
    
    def _check_vtep_ip_conflicts(self):
        """Check for duplicate VTEP source IPs (MLAG pairs should share)."""
        for ip, devices in self.report.vtep_ips.items():
            if len(devices) > 2:
                self.report.issues.append(TopologyIssue(
                    severity=Severity.ERROR,
                    category="VTEP IP Conflict",
                    message=f"Same VTEP IP '{ip}' used on more than 2 devices",
                    devices=devices,
                    suggestion="Only MLAG peers should share VTEP IP (anycast)"
                ))
    
    def _check_vrf_asn_consistency(self):
        """Check that all VRFs on same device use same ASN."""
        for device, vrf_asns in self.report.vrf_asn_map.items():
            if len(vrf_asns) > 1:
                unique_asns = set(vrf_asns.values())
                if len(unique_asns) > 1:
                    vrfs_info = ", ".join([f"{vrf}={asn}" for vrf, asn in vrf_asns.items()])
                    self.report.issues.append(TopologyIssue(
                        severity=Severity.ERROR,
                        category="VRF ASN Mismatch",
                        message=f"Different ASNs configured in VRFs: {vrfs_info}",
                        devices=[device],
                        suggestion="All VRFs on a device should use the same ASN"
                    ))
    
    def _check_vlan_vni_consistency(self):
        """Check VLAN-VNI mapping consistency across devices."""
        # Collect all VLAN-VNI mappings
        global_vlan_vni: Dict[int, Dict[int, List[str]]] = {}  # vlan -> {vni -> [devices]}
        
        for device, vlan_vni in self.report.vlan_vni_map.items():
            for vlan, vni in vlan_vni.items():
                if vlan not in global_vlan_vni:
                    global_vlan_vni[vlan] = {}
                if vni not in global_vlan_vni[vlan]:
                    global_vlan_vni[vlan][vni] = []
                global_vlan_vni[vlan][vni].append(device)
        
        # Check for inconsistencies
        for vlan, vni_devices in global_vlan_vni.items():
            if len(vni_devices) > 1:
                # Same VLAN mapped to different VNIs - format nicely
                mapping_lines = []
                for vni, devs in sorted(vni_devices.items()):
                    mapping_lines.append(f"VNI {vni}: {', '.join(sorted(devs))}")
                
                all_devices = [d for devs in vni_devices.values() for d in devs]
                self.report.issues.append(TopologyIssue(
                    severity=Severity.ERROR,
                    category="VLAN-VNI Mismatch",
                    message=f"VLAN {vlan} mapped to different VNIs",
                    devices=list(set(all_devices)),
                    suggestion="Same VLAN must map to same VNI across all devices",
                    details=mapping_lines
                ))
    
    def _check_vrf_l3vni_consistency(self):
        """Check VRF L3VNI mapping consistency across devices."""
        # Collect all VRF-L3VNI mappings
        global_vrf_l3vni: Dict[str, Dict[int, List[str]]] = {}  # vrf -> {l3vni -> [devices]}
        
        for device, vrf_l3vni in self.report.vrf_l3vni_map.items():
            for vrf, l3vni in vrf_l3vni.items():
                if vrf not in global_vrf_l3vni:
                    global_vrf_l3vni[vrf] = {}
                if l3vni not in global_vrf_l3vni[vrf]:
                    global_vrf_l3vni[vrf][l3vni] = []
                global_vrf_l3vni[vrf][l3vni].append(device)
        
        # Check for inconsistencies
        for vrf, l3vni_devices in global_vrf_l3vni.items():
            if len(l3vni_devices) > 1:
                # Format nicely
                mapping_lines = []
                for vni, devs in sorted(l3vni_devices.items()):
                    mapping_lines.append(f"L3VNI {vni}: {', '.join(sorted(devs))}")
                
                all_devices = [d for devs in l3vni_devices.values() for d in devs]
                self.report.issues.append(TopologyIssue(
                    severity=Severity.ERROR,
                    category="VRF L3VNI Mismatch",
                    message=f"VRF '{vrf}' has different L3VNIs",
                    devices=list(set(all_devices)),
                    suggestion="Same VRF must use same L3VNI across all devices",
                    details=mapping_lines
                ))


def print_topology_report(report: TopologyReport, verbose: bool = False):
    """Print topology analysis report."""
    print("\n" + "=" * 60)
    print("TOPOLOGY ANALYSIS")
    print("=" * 60)
    
    if not report.issues:
        print("\n[OK] No topology issues found!")
    else:
        errors = [i for i in report.issues if i.severity == Severity.ERROR]
        warnings = [i for i in report.issues if i.severity == Severity.WARNING]
        
        if errors:
            print(f"\n\033[31mTOPOLOGY ERRORS ({len(errors)}):\033[0m")
            for issue in errors:
                print(f"\n  * {issue.category}: {issue.message}")
                if issue.details:
                    for detail in issue.details:
                        print(f"      - {detail}")
                print(f"    Devices: {', '.join(sorted(issue.devices))}")
                if issue.suggestion:
                    print(f"    -> {issue.suggestion}")
        
        if warnings:
            print(f"\n\033[33mTOPOLOGY WARNINGS ({len(warnings)}):\033[0m")
            for issue in warnings:
                print(f"\n  * {issue.category}: {issue.message}")
                if issue.details:
                    for detail in issue.details:
                        print(f"      - {detail}")
                print(f"    Devices: {', '.join(sorted(issue.devices))}")
                if issue.suggestion and verbose:
                    print(f"    -> {issue.suggestion}")


def generate_full_report(report: TopologyReport, results: List[ValidationResult], use_colors: bool = True) -> str:
    """Generate comprehensive topology report with all collected data."""
    lines = []
    
    lines.append("\n" + "=" * 60)
    lines.append("TOPOLOGY REPORT")
    lines.append("=" * 60)
    
    # Device summary
    lines.append(f"\n[DEVICES] ({len(report.devices)})")
    lines.append("-" * 40)
    for device in sorted(report.devices.keys()):
        data = report.devices[device]
        lo_ips = ", ".join(data['loopback_ips']) if data['loopback_ips'] else "N/A"
        lines.append(f"  {device}:")
        lines.append(f"    Loopback: {lo_ips}")
        if data['vtep_ip']:
            lines.append(f"    VTEP IP: {data['vtep_ip']}")
        if data['mlag_mac']:
            lines.append(f"    MLAG MAC: {data['mlag_mac']}")
        if data['vrf_asn']:
            asns = ", ".join([f"{v}={a}" for v, a in data['vrf_asn'].items()])
            lines.append(f"    VRF ASNs: {asns}")
    
    # Loopback IPs
    if report.loopback_ips:
        lines.append(f"\n[LOOPBACK IPs] ({len(report.loopback_ips)})")
        lines.append("-" * 40)
        for ip, devices in sorted(report.loopback_ips.items()):
            status = "[OK]" if len(devices) == 1 else "[CONFLICT]"
            lines.append(f"  {ip}: {', '.join(devices)} {status}")
    
    # MLAG Pairs
    if report.mlag_macs:
        lines.append(f"\n[MLAG PAIRS] ({len(report.mlag_macs)})")
        lines.append("-" * 40)
        for mac, devices in sorted(report.mlag_macs.items()):
            status = "[OK]" if len(devices) == 2 else "[WARN]"
            lines.append(f"  {mac}: {', '.join(devices)} {status}")
    
    # VTEP IPs
    if report.vtep_ips:
        lines.append(f"\n[VTEP IPs] ({len(report.vtep_ips)})")
        lines.append("-" * 40)
        for ip, devices in sorted(report.vtep_ips.items()):
            lines.append(f"  {ip}: {', '.join(devices)}")
    
    # VLAN-VNI Mappings
    all_vlan_vni = {}
    for device, mappings in report.vlan_vni_map.items():
        for vlan, vni in mappings.items():
            if vlan not in all_vlan_vni:
                all_vlan_vni[vlan] = vni
    
    if all_vlan_vni:
        lines.append(f"\n[VLAN-VNI MAPPINGS] ({len(all_vlan_vni)})")
        lines.append("-" * 40)
        for vlan, vni in sorted(all_vlan_vni.items()):
            lines.append(f"  VLAN {vlan} -> VNI {vni}")
    
    # VRF L3VNI Mappings
    all_vrf_l3vni = {}
    for device, mappings in report.vrf_l3vni_map.items():
        for vrf, l3vni in mappings.items():
            if vrf not in all_vrf_l3vni:
                all_vrf_l3vni[vrf] = l3vni
    
    if all_vrf_l3vni:
        lines.append(f"\n[VRF L3VNI MAPPINGS] ({len(all_vrf_l3vni)})")
        lines.append("-" * 40)
        for vrf, l3vni in sorted(all_vrf_l3vni.items()):
            lines.append(f"  {vrf} -> L3VNI {l3vni}")
    
    # Issues summary
    lines.append("\n" + "=" * 60)
    lines.append("TOPOLOGY ISSUES")
    lines.append("=" * 60)
    
    if not report.issues:
        lines.append("\n[OK] No topology issues found!")
    else:
        errors = [i for i in report.issues if i.severity == Severity.ERROR]
        warnings = [i for i in report.issues if i.severity == Severity.WARNING]
        
        if errors:
            lines.append(f"\nERRORS ({len(errors)}):")
            for issue in errors:
                lines.append(f"\n  * {issue.category}: {issue.message}")
                if issue.details:
                    for detail in issue.details:
                        lines.append(f"      - {detail}")
                lines.append(f"    Devices: {', '.join(sorted(issue.devices))}")
                if issue.suggestion:
                    lines.append(f"    -> {issue.suggestion}")
        
        if warnings:
            lines.append(f"\nWARNINGS ({len(warnings)}):")
            for issue in warnings:
                lines.append(f"\n  * {issue.category}: {issue.message}")
                if issue.details:
                    for detail in issue.details:
                        lines.append(f"      - {detail}")
                lines.append(f"    Devices: {', '.join(sorted(issue.devices))}")
                if issue.suggestion:
                    lines.append(f"    -> {issue.suggestion}")
    
    # Per-file validation summary
    lines.append("\n" + "=" * 60)
    lines.append("FILE VALIDATION SUMMARY")
    lines.append("=" * 60)
    for result in results:
        device_name = Path(result.filename).stem
        status = "[OK]" if result.is_valid else "[FAIL]"
        lines.append(f"  {status} {device_name}: {result.error_count} errors, {result.warning_count} warnings")
    
    return "\n".join(lines)


def print_full_report(report: TopologyReport, results: List[ValidationResult]):
    """Print comprehensive topology report with all collected data."""
    report_text = generate_full_report(report, results, use_colors=True)
    print(report_text)


def save_report_to_file(report: TopologyReport, results: List[ValidationResult], 
                        output_path: Path, total_errors: int, total_warnings: int,
                        topology_errors: int, topology_warnings: int):
    """Save the full report to a text file."""
    from datetime import datetime
    
    lines = []
    lines.append("=" * 60)
    lines.append("NVUE YAML VALIDATION REPORT")
    lines.append("=" * 60)
    lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append(f"Total devices: {len(results)}")
    lines.append("")
    
    # Add full topology report
    lines.append(generate_full_report(report, results, use_colors=False))
    
    # Summary
    lines.append("\n" + "=" * 60)
    lines.append("SUMMARY")
    lines.append("=" * 60)
    valid_count = sum(1 for r in results if r.is_valid)
    lines.append(f"Files: {len(results)} total, {valid_count} valid, {len(results) - valid_count} invalid")
    lines.append(f"File validation: {total_errors} errors, {total_warnings} warnings")
    lines.append(f"Topology analysis: {topology_errors} errors, {topology_warnings} warnings")
    lines.append(f"Total issues: {total_errors + topology_errors} errors, {total_warnings + topology_warnings} warnings")
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write("\n".join(lines))
    
    return output_path


# ============================================================================
# MAIN FUNCTIONS
# ============================================================================

def validate_file(input_file: Path) -> ValidationResult:
    """Validate a single YAML file."""
    try:
        with open(input_file, 'r') as f:
            yaml_content = yaml.safe_load(f)
    except yaml.YAMLError as e:
        result = ValidationResult(str(input_file))
        result.issues.append(ValidationIssue(
            Severity.ERROR, 
            "yaml", 
            f"YAML parse error: {e}"
        ))
        return result
    except Exception as e:
        result = ValidationResult(str(input_file))
        result.issues.append(ValidationIssue(
            Severity.ERROR,
            "file",
            f"File read error: {e}"
        ))
        return result
    
    validator = NVUEValidator()
    return validator.validate(yaml_content, str(input_file))


def validate_directory(input_dir: Path) -> List[ValidationResult]:
    """Validate all YAML files in a directory."""
    yaml_files = list(input_dir.glob('*.yaml')) + list(input_dir.glob('*.yml'))
    
    if not yaml_files:
        print(f"âš  No YAML files found in directory: {input_dir}", file=sys.stderr)
        return []
    
    results = []
    for yaml_file in sorted(yaml_files):
        result = validate_file(yaml_file)
        results.append(result)
    
    return results


def print_result(result: ValidationResult, verbose: bool = False):
    """Print validation result."""
    status = "âœ“" if result.is_valid else "âœ—"
    color_code = "\033[32m" if result.is_valid else "\033[31m"
    reset_code = "\033[0m"
    bold_code = "\033[1m"
    
    # Extract device name and filename from path
    filepath = Path(result.filename)
    device_name = filepath.stem
    filename_only = filepath.name
    
    # Print device name prominently
    print(f"\n{color_code}{status} {bold_code}[ {device_name} ]{reset_code}")
    print()
    print(f"   File: {filename_only}")
    
    if result.issues:
        print(f"   Errors: {result.error_count}, Warnings: {result.warning_count}")
        
        # Group by severity
        errors = [i for i in result.issues if i.severity == Severity.ERROR]
        warnings = [i for i in result.issues if i.severity == Severity.WARNING]
        
        if errors:
            print(f"\n   {color_code}ERRORS:{reset_code}")
            for issue in errors:
                print(f"   â€¢ {issue.path}: {issue.message}")
                if issue.suggestion:
                    print(f"     â†’ Suggestion: {issue.suggestion}")
        
        if warnings:
            print(f"\n   \033[33mWARNINGS:\033[0m")
            for issue in warnings[:10]:  # Limit warnings shown
                print(f"   â€¢ {issue.path}: {issue.message}")
                if issue.suggestion and verbose:
                    print(f"     â†’ Suggestion: {issue.suggestion}")
            if len(warnings) > 10:
                print(f"   ... and {len(warnings) - 10} more warnings")
    else:
        print("   No issues found!")


def main():
    parser = argparse.ArgumentParser(
        description='NVUE YAML configuration validator with topology analysis',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                                      # Validate all files in default directory
  %(prog)s config.yaml                          # Validate single file
  %(prog)s --dir ./configs/                     # Validate files in specific directory
  %(prog)s --dir ./configs/ -r                  # Full topology report
  %(prog)s --dir ./configs/ -o report.txt       # Save report to file
  %(prog)s --dir ./configs/ -r -o report.txt    # Full report + save to file
  %(prog)s --dir ./configs/ --no-topology       # Skip topology analysis
  %(prog)s config.yaml -v                       # Verbose output

This script validates NVUE YAML configurations according to Cumulus Linux documentation.
Topology analysis checks for IP conflicts, MAC conflicts, VLAN-VNI consistency, etc.
        """
    )
    
    parser.add_argument('input_file', nargs='?', help='YAML file to validate')
    parser.add_argument('--dir', dest='input_dir', help='Directory containing files to validate')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-r', '--report', action='store_true', help='Full topology report')
    parser.add_argument('-o', '--output', dest='output_file', help='Save report to file (e.g., report.txt)')
    parser.add_argument('--no-topology', action='store_true', help='Skip topology analysis')
    parser.add_argument('-s', '--strict', action='store_true', help='Strict mode: also check VLAN-VNI consistency across all devices')
    parser.add_argument('--json', action='store_true', help='JSON format output')
    
    args = parser.parse_args()
    
    if args.input_file:
        # Single file mode
        result = validate_file(Path(args.input_file))
        
        if args.json:
            import json
            print(json.dumps({
                'filename': result.filename,
                'valid': result.is_valid,
                'errors': result.error_count,
                'warnings': result.warning_count,
                'issues': [
                    {
                        'severity': i.severity.value,
                        'path': i.path,
                        'message': i.message,
                        'suggestion': i.suggestion
                    }
                    for i in result.issues
                ]
            }, indent=2, ensure_ascii=False))
        else:
            print_result(result, args.verbose)
        
        sys.exit(0 if result.is_valid else 1)
    
    else:
        # Directory mode with topology analysis
        input_dir = Path(args.input_dir) if args.input_dir else DEFAULT_INPUT_DIR
        
        if not input_dir.exists():
            if args.json:
                import json
                print(json.dumps({'valid': False, 'error': f'Directory not found: {input_dir}'}))
            else:
                print(f"âœ— Directory not found: {input_dir}", file=sys.stderr)
            sys.exit(1)
        
        if not args.json:
            print(f"NVUE YAML Validator")
            print(f"Directory: {input_dir.resolve()}")
            print("=" * 60)
        
        # Validate individual files
        results = validate_directory(input_dir)
        
        if not results:
            sys.exit(1)
        
        # Topology analysis (default enabled)
        topology_analyzer = TopologyAnalyzer()
        topology_errors = 0
        
        if not args.no_topology:
            # Load YAML content for topology analysis
            yaml_files = list(input_dir.glob('*.yaml')) + list(input_dir.glob('*.yml'))
            for yaml_file in yaml_files:
                try:
                    with open(yaml_file, 'r') as f:
                        yaml_content = yaml.safe_load(f)
                    device_name = yaml_file.stem
                    topology_analyzer.add_device(device_name, yaml_content)
                except Exception:
                    pass
            
            topology_report = topology_analyzer.analyze(strict=args.strict)
            topology_errors = topology_report.error_count
        
        total_errors = sum(r.error_count for r in results)
        total_warnings = sum(r.warning_count for r in results)
        valid_count = sum(1 for r in results if r.is_valid)
        
        all_errors = total_errors + topology_errors
        
        # JSON output mode for directory
        if args.json:
            import json
            output = {
                'valid': all_errors == 0,
                'summary': {
                    'total_files': len(results),
                    'valid_files': valid_count,
                    'invalid_files': len(results) - valid_count,
                    'total_errors': total_errors,
                    'total_warnings': total_warnings,
                    'topology_errors': topology_report.error_count if not args.no_topology else 0,
                    'topology_warnings': topology_report.warning_count if not args.no_topology else 0
                },
                'files': [
                    {
                        'filename': r.filename,
                        'valid': r.is_valid,
                        'errors': r.error_count,
                        'warnings': r.warning_count,
                        'issues': [
                            {
                                'severity': i.severity.value,
                                'path': i.path,
                                'message': i.message,
                                'suggestion': i.suggestion
                            }
                            for i in r.issues
                        ]
                    }
                    for r in results
                ],
                'topology': {
                    'errors': topology_report.error_count,
                    'warnings': topology_report.warning_count,
                    'issues': [
                        {
                            'severity': i.severity.value,
                            'category': i.category,
                            'message': i.message,
                            'devices': i.devices,
                            'suggestion': i.suggestion,
                            'details': i.details
                        }
                        for i in topology_report.issues
                    ]
                } if not args.no_topology else None
            }
            print(json.dumps(output, indent=2, ensure_ascii=False))
            sys.exit(0 if all_errors == 0 else 1)
        
        # Print results based on mode
        if args.report:
            # Full report mode
            print_full_report(topology_report, results)
        else:
            # Standard mode
            for result in results:
                if result.issues or args.verbose:
                    print_result(result, args.verbose)
            
            # Print topology analysis results
            if not args.no_topology:
                print_topology_report(topology_report, args.verbose)
        
        # Summary
        print("\n" + "=" * 60)
        print(f"Summary: {len(results)} files, {valid_count} valid, "
              f"{len(results) - valid_count} invalid")
        print(f"File validation: {total_errors} errors, {total_warnings} warnings")
        if not args.no_topology:
            print(f"Topology analysis: {topology_report.error_count} errors, {topology_report.warning_count} warnings")
        
        # Save report to file if requested
        if args.output_file and not args.no_topology:
            output_path = Path(args.output_file)
            save_report_to_file(
                topology_report, results, output_path,
                total_errors, total_warnings,
                topology_report.error_count, topology_report.warning_count
            )
            print(f"\nReport saved to: {output_path.resolve()}")
        
        sys.exit(0 if all_errors == 0 else 1)


if __name__ == '__main__':
    main()
