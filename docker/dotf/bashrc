# System-wide .bashrc file for interactive bash(1) shells.

# To enable the settings / commands in this file for login shells as well,
# this file has to be sourced in /etc/profile.

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, overwrite the one in /etc/profile)
# but only if not SUDOing and have SUDO_PS1 set; then assume smart user.
if ! [ -n "${SUDO_USER}" -a -n "${SUDO_PS1}" ]; then
  PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi

# Commented out, don't overwrite xterm -T "title" -n "icontitle" by default.
# If this is an xterm set the title to user@host:dir
#case "$TERM" in
#xterm*|rxvt*)
#    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
#    ;;
#*)
#    ;;
#esac

# enable bash completion in interactive shells
#if ! shopt -oq posix; then
#  if [ -f /usr/share/bash-completion/bash_completion ]; then
#    . /usr/share/bash-completion/bash_completion
#  elif [ -f /etc/bash_completion ]; then
#    . /etc/bash_completion
#  fi
#fi
BASE_PS1='\[\e[1;33m\][\[\e[0;31m\]\h\[\e[1;33m\]] \[\e[1;35m\][\[\e[0;33m\]\W\[\e[1;35m\]] '

if [ -f /usr/lib/git-core/git-sh-prompt ]; then
  . /usr/lib/git-core/git-sh-prompt
elif [ -f /etc/bash_completion.d/git-prompt ]; then
  . /etc/bash_completion.d/git-prompt
elif [ -f /usr/share/git-core/contrib/completion/git-prompt.sh ]; then
  . /usr/share/git-core/contrib/completion/git-prompt.sh
fi

__git_modified_count() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 0
  local m
  m=$(git status --porcelain 2>/dev/null | awk 'substr($0,2,1)!=" " && substr($0,1,2)!="??"{c++} END{print c+0}')
  (( m == 0 )) && return 0
  printf "~%s" "$m"
}

__set_prompt() {
  local ps="$BASE_PS1"

  while [[ "$ps" == *" " ]]; do
    ps="${ps% }"
  done

  if declare -F __git_ps1 >/dev/null 2>&1; then
    unset GIT_PS1_SHOWDIRTYSTATE

    local br
    br="$(__git_ps1 '%s')"
    if [ -n "$br" ]; then
      ps+=" \[\e[0;36m\][${br}]\[\e[0m\]"
    fi
  fi

  local cnt
  cnt="$(__git_modified_count)"
  if [ -n "$cnt" ]; then
    ps+=" \[\e[0;36m\][${cnt}]\[\e[0m\]"
  fi
  if [ "$EUID" -eq 0 ]; then
    ps+=" \[\e[1;34m\]#\[\e[0m\]\n"
  else
    ps+=" \[\e[1;34m\]$\[\e[0m\]\n"
  fi

  PS1="$ps"
}

case ";$PROMPT_COMMAND;" in
  *";__set_prompt;"*) : ;;
  *) PROMPT_COMMAND="__set_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}" ;;
esac
PS2='\[\e[0;31m\]Here_You_Are\[\e[m > '

rm -rf $HOME/.lesshst
rm -rf $HOME/.rnd
rm -rf $HOME/.viminfo
rm -rf $HOME/.wget-hsts

stty -ixon
shopt -s checkwinsize
shopt -s histappend

export TERM=xterm-256color
export EDITOR='nano -cu'
export VISUAL='nano -cu'

[[ -r "/usr/share/z/z.sh" ]] && source /usr/share/z/z.sh

HISTCONTROL=ignoredups:ignorespace
HISTSIZE=10000000
HISTFILESIZE=10000000
HISTTIMEFORMAT='%d-%m-%Y %T => '

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

alias ls="ls --color=auto"

alias l="exa -lh --group-directories-first --color=always"
alias ll="exa -lah --group-directories-first --color=always"
alias lll="exa -lahg --group-directories-first --color=always"
alias l-="exa -lh --group-directories-first --color=always | nl -v 0"
alias ll-="exa -lah --group-directories-first --color=always | nl -v 0"
alias lll-="exa -lahg --group-directories-first --color=always | nl -v 0"
alias lls="exa -a --sort=name --color=always"
alias lg="exa -lh --group-directories-first --color=always --git"
alias llg="exa -lah --group-directories-first --color=always --git"
alias ld="exa -lahg --group-directories-first --color=always"
alias lh="exa -lahg --sort=modified --color=always"
alias lz="exa -lah --group-directories-first --sort=size --color=always"
alias lS="exa -lah --group-directories-first --sort=size --color=always"
alias lt="exa -lahgT --group-directories-first --color=always"
alias lt1="exa -lahgT -L 2 --group-directories-first --color=always"
alias lt2="exa -lahgT -L 3 --group-directories-first --color=always"
alias lt3="exa -lahgT -L 4 --group-directories-first --color=always"
alias lth="exa -lahgT --sort=modified --group-directories-first --color=always"

#alias l="eza -Xlh --color=always --icons --group-directories-first"
#alias ll="eza -Xlah --color=always --icons --group-directories-first"
#alias lll="eza -Xlahg --color=always --icons --group-directories-first"
#alias l-="eza -Xlh --color=always --icons --group-directories-first | nl -v 0"
#alias ll-="eza -Xlah --color=always --icons --group-directories-first | nl -v 0"
#alias lll-="eza -Xlahg --color=always --icons --group-directories-first | nl -v 0"
#alias lls="eza -as name --color=always --icons"
#alias lg="eza -Xlh --color=always --icons --group-directories-first --git"
#alias llg="eza -Xlah --color=always --icons --group-directories-first --git"
#alias ld="eza -lahgmDs name --group-directories-first --color=always --icons"
#alias lh="eza -Xlahgms modified --color=always --icons"
#alias lz="eza -Xlah --color=always --icons --group-directories-first --sort size"
#alias lS="eza -Xlah --color=always --icons --group-directories-first --total-size --sort size"
#alias lt="eza -XlahgmT --color=always --icons --group-directories-first"
#alias lt1="eza -XlahgmT -L 2 --color=always --icons --group-directories-first"
#alias lt2="eza -XlahgmT -L 3 --color=always --icons --group-directories-first"
#alias lt3="eza -XlahgmT -L 4 --color=always --icons --group-directories-first"
#alias lth="eza -XlahgmTs modified --color=always --icons --group-directories-first"

alias free='free -h'
alias cal='cal -m'
alias dirs='dirs -v'
alias ss4='sudo netstat -4tulpn | grep -v 127.0.0'
alias ss6='sudo netstat -6tulpn | grep -v 127.0.0'
alias SS='sudo netstat -tulpn | grep -v 127 | uniq'
alias diff='colordiff'

alias du1='sudo du -xch --max-depth=1 2> /dev/null | sort -h'
alias du1m='sudo du -xcm --max-depth=1 2> /dev/null | sort -h'
alias du1k='sudo du -xck --max-depth=1 2> /dev/null | sort -h'
alias du2='sudo du -xch --max-depth=2 2> /dev/null | sort -h'

alias rm="rm -ri"
alias mv="mv -i"
alias cp="cp -ri"
alias mkdir="mkdir -pv"
alias del="rm -rf "

alias dmesg='sudo dmesg -L'
alias car='cat -n'
alias cay='cat -ne'
alias can="grep -v '^#'"
alias mkdir='mkdir -pv'
alias nn='nano -cu'
alias nnl='nano -lcu'
alias mm='micro'
alias vv='nvim'
alias ping='ping -c 5'
alias ping6='ping -6 -c 5'
alias c="clear"
alias h="history"
alias grep="grep --color=auto"
alias egrep="egrep --color=auto"
alias fgrep="fgrep --color=auto"
alias rr4="sudo route -n"
alias rr6="sudo route -6 -n"
alias saat="date +'%T'"
alias sys="systemctl --type=service"
alias syss="systemctl list-unit-files"
alias hava="curl http://wttr.in/ISTANBUL"
alias ipp="curl -s icanhazip.com"
alias ipr="ip -br a"
alias sudo="sudo "
alias rr="ranger"
alias src="source /etc/profile"
alias ubuntuo="chown -R ubuntu:ubuntu /home/ubuntu/"
alias ubuntu="su - ubuntu"
alias root="sudo su -"
alias FF="fastfetch"

alias GEN="ansible-playbook playbooks/generate_switch_nvue_yaml_configs.yaml"
alias DEP="ansible-playbook playbooks/deploy_switch_configs.yaml"
alias DIF="ansible-playbook playbooks/diff_switch_configs.yaml"

alias gpull='git pull --rebase'
alias gadd='git add . && git commit -m NVIS && git push'
alias gdff='git fetch --prune origin && { echo "=== local -> remote (you ahead?) ==="; git diff --stat @{u}..HEAD; echo; echo "=== remote -> local (remote ahead?) ==="; git diff --stat HEAD..@{u}; }'
alias gdfc='git fetch --prune origin && git log --oneline --decorate --left-right HEAD...@{u}'
alias gdf='git fetch --prune origin && git diff --stat HEAD..@{u}'
alias gss="git status --short"
alias gst="git status"

function ghis () { local br lbl; br=$(git symbolic-ref --quiet --short HEAD 2>/dev/null) || br=""; if [ "$br" = "main" ]; then lbl="(main)"; elif [ -z "$br" ]; then lbl="(HEAD)"; else lbl=""; fi; git -c color.ui=always --no-pager log --color=always --graph --decorate=no --date=iso --pretty=format:"%C(yellow)%<(8,trunc)%h%Creset %C(cyan)%<(25,trunc)%cd%Creset %C(blue)%<(10,trunc)%cr%Creset %C(magenta)%<(11,trunc)%an%Creset %C(white)%s%Creset" -n 30 | awk -v lbl="$lbl" 'NR==1 && lbl!="" {print $0" "lbl; next} {print}'; echo; }
function g-dif () { git diff "$1..${2:-HEAD}" ; }
function g-difs() { git diff "$1..${2:-HEAD}" --stat ; }
function hgrep () { history | grep -i --color "$1"; }
#function mgrep () { sudo grep -rnIi --color "$1" "${@: 2}"; }
function cgrep () { grep --color=always -e "^" -e "$1" "${@: 2}"; }
function x () { for run in {1..99}; do echo ""; done  }
function C () { curl cheat.sh/$1 ;}
function dff () { DFF0=$(df -HT | head -n 1);DFF1=$(df -HT | grep "/dev/root");DFF2=$(df -HT | grep "/dev/sda");DFF=$(sudo df -HT | grep -v tmpfs | grep -v root | grep -v sda| grep -v snap | grep -v www | tail -n +2);FRR0=$(free | head -n 1);FRR1=$(sudo free -h | tail -n +2);FRR2=$(sudo free -ht | grep Total);echo "";echo -e "\e[1;32m$DFF0\e[0m";echo -e "\e[1;33m$DFF1\e[0m";echo -e "\e[0;31m$DFF2\e[0m";echo"";echo -e "\e[1;31m$DFF\e[0m";echo "";echo -e "\e[1;32m$FRR0\e[0m";echo -e "\e[1;33m$FRR1\e[0m";echo -e "\e[1;31m$FRR2\e[0m";echo ""; }
function pss () { sudo ps -ef | grep $1 | grep -v grep; }
function psk () { sudo ps auxf | grep -v \\[ | grep -v ps ; }
function macs () { /usr/sbin/bridge fdb | grep "$*" | sorti 3 ; }
function arps () { /usr/sbin/ip -4 neighbor | grep "$*" | sorti 1 | column -t ; }
function mgrep () {
  local opts="-rnIi"
  while [[ "$1" == -* ]]; do
    case "$1" in
      -N) opts="-rIi"; shift ;;
      -l) opts="-rlIi"; shift ;;
      *) break ;;
    esac
  done
  sudo grep $opts --color=always "$1" "${@:2}"
}
function iff () {
  ip addr | sed -E "/127/! s|([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)|$(tput setab 1)$(tput setaf 0)\1$(tput sgr0)|"
}

function sorti() {
    args=()
    for arg in "$@"; do
        col="${arg%[A-Za-z]}"
        type="${arg##*[0-9]}"
        case "$type" in
            n) args+=("-k${col},${col}n") ;;    # numeric
            V|"") args+=("-k${col},${col}V") ;; # default or explicit V
            *) args+=("-k${col},${col}V") ;;    # fallback = natural
        esac
    done
    sort "${args[@]}"
}

function sedi() {
  if [ "$#" -lt 3 ]; then
    echo "Usage: sedi <search> <replace> <file...>" >&2
    return 2
  fi
  local find="$1" repl="$2"
  shift 2
  local find_esc
  find_esc=$(printf '%s' "$find" | sed -e 's/[.[\*^$(){}+?|\\]/\\&/g')
  local repl_esc
  repl_esc=$(printf '%s' "$repl" | sed -e 's/[|&\\]/\\&/g')
  sed -i "s|$find_esc|$repl_esc|g" "$@"
}

function ip4 () {
  ip addr | awk '
    BEGIN{
      blue="\033[1;34m"; bold="\033[1m"; dim="\033[2m"; reset="\033[0m"
      w1=12; w2=15; w3=5; w4=15
      top="┌" line(w1) "┬" line(w2) "┬" line(w3) "┬" line(w4) "┐"
      mid="├" line(w1) "┼" line(w2) "┼" line(w3) "┼" line(w4) "┤"
      bot="└" line(w1) "┴" line(w2) "┴" line(w3) "┴" line(w4) "┘"
      print ""; print top
      print "│" pad(bold "Interface" reset,w1) "│" pad(bold "IPv4 Address" reset,w2) "│" pad(bold "CIDR" reset,w3) "│" pad(bold "Netmask" reset,w4) "│"
      print mid
    }
    function line(n,  s,i){ s=""; for(i=0;i<n;i++) s=s "─"; return s }
    function vislen(s,  t){ t=s; gsub(/\x1B\[[0-9;]*m/,"",t); return length(t) }
    function pad(s,w,  l,sp){ l=vislen(s); sp=(w-l>0?w-l:0); return s sprintf("%" sp "s","") }
    function cidr2mask(c,  full,rem,i,oct){
      full=int(c/8); rem=c%8
      for(i=0;i<4;i++){
        if(i<full) oct[i]=255
        else if(i==full) oct[i]=(rem?256-(2^(8-rem)):0)
        else oct[i]=0
      }
      return sprintf("%d.%d.%d.%d",oct[0],oct[1],oct[2],oct[3])
    }
    /^[0-9]+:/ { iface=$2; gsub(":", "", iface) }
    /inet / && $0 !~ / 127\./ {
      ipaddr=""; cidr=""
      for(i=1;i<=NF;i++) if($i=="inet"){ ipfield=$(i+1); break }
      split(ipfield,a,"/"); ipaddr=a[1]; cidr=a[2]
      if(cidr==""){
        if(match($0,/peer[[:space:]]+[0-9.]+\/([0-9]+)/,m)) cidr=m[1]
      }
      if(cidr=="") cidr=0
      mask=cidr2mask(cidr)
      print "│" pad(blue iface reset,w1) "│" pad(ipaddr,w2) "│" pad(cidr,w3) "│" pad(mask,w4) "│"
    }
    END{ print bot; print "" }
  '
}

function cale () {
DATE=$(date +'%d-%m-%Y')
CLOK=$(date +'%T')
BOLD=$(tput bold)
BGCL=$(tput setab 1)
FGCL=$(tput setaf 3)
REVE=$(tput rev)
RSET=$(tput sgr0)
DAYS=$(date +%-e)
if [[ "$DAYS" == 1 ]] || [[ "$DAYS" == 2 ]] || [[ "$DAYS" == 3 ]]; then
if [ $(date +%w) = 0 ]; then
CALL=$(ncal -b -M -h | sed -E -e "s/($(date +%B)) ($(date +%Y))/$(tput bold)$(tput setaf 2)$(tput smul)\1$(tput rmul) $(tput setaf 1)$(tput smul)\2$(tput sgr0)/" | sed -E -e "/$(date +%Y)/!s|(.*[^0-9])($DAYS)([^0-9]*$)|\1$BGCL$BOLD$FGCL\2$RSET\3|")
else
CALL=$(ncal -b -M -h | sed -E -e "s/($(date +%B)) ($(date +%Y))/$(tput bold)$(tput setaf 2)$(tput smul)\1$(tput rmul) $(tput setaf 1)$(tput smul)\2$(tput sgr0)/" | sed -E -e "/$(date +%Y)/!s|(.*[^0-9])($DAYS)([^0-9]$*)|\1$BGCL$BOLD$FGCL\2$RSET\3|")
fi
elif [[ "$DAYS" == [0-9] ]]; then
CALL=$(ncal -b -M -h | sed -E -e "s/($(date +%B)) ($(date +%Y))/$(tput bold)$(tput setaf 2)$(tput smul)\1$(tput rmul) $(tput setaf 1)$(tput smul)\2$(tput sgr0)/" | sed -E -e "/$(date +%Y)/!s|(.*[^0-9])($DAYS)|\1$BGCL$BOLD$FGCL\2$RSET|")
else
CALL=$(ncal -b -M -h | sed -E -e"s/($(date +%B)) ($(date +%Y))/$(tput bold)$(tput setaf 2)$(tput smul)\1$(tput rmul) $(tput setaf 1)$(tput smul)\2$(tput sgr0)/" | sed -E -e "/$(date +%Y)/!s|(.*[^0-9]?)($DAYS)|\1$BGCL$BOLD$FGCL\2$RSET|")
fi
echo -e ""
echo -e "     \e[1;34m$DATE\e[0m"
echo -e "      \e[1;33m$CLOK\e[0m"
echo -e ""
paste <(echo -e "$CALL")
}
