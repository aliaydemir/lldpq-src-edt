#!/usr/bin/env bash
# LLDPq Trigger - Self-loop daemon for web interface triggers
# Add to crontab: * * * * * /usr/local/bin/lldpq-trigger
# Copyright (c) 2024 LLDPq Project - Licensed under MIT License

# Load config
source /etc/lldpq.conf 2>/dev/null || true
LLDPQ_DIR="${LLDPQ_DIR:-$HOME/lldpq}"
LLDP_TRIGGER_FILE="/tmp/.lldp_web_trigger"
MONITOR_TRIGGER_FILE="/tmp/.monitor_web_trigger"
ASSETS_TRIGGER_FILE="/tmp/.assets_web_trigger"
DAEMON_PID_FILE="/tmp/lldp_trigger_daemon.pid"
LLDP_LOCK_FILE="/tmp/lldp_running.lock"
ASSETS_LOCK_FILE="/tmp/assets_running.lock"

# Exit if daemon already running
if [ -f "$DAEMON_PID_FILE" ]; then
    # Check if process is actually running
    if kill -0 "$(cat "$DAEMON_PID_FILE")" 2>/dev/null; then
        exit 0
    else
        # Stale PID file, remove it
        rm -f "$DAEMON_PID_FILE"
    fi
fi

# Create PID file for daemon
echo $$ > "$DAEMON_PID_FILE"

# Cleanup function
cleanup() {
    rm -f "$DAEMON_PID_FILE"
    exit 0
}

# Set trap for cleanup on exit
trap cleanup SIGTERM SIGINT EXIT

# Wait function to prevent conflicts
wait_until_not_running() {
    local script_name="$1"
    while pgrep -f "$script_name" >/dev/null; do
        sleep 2
    done
}

# Main daemon loop - check every 5 seconds
LLDP_LAST_CHECK_FILE="$LLDPQ_DIR/.last_lldp_trigger_check"
MONITOR_LAST_CHECK_FILE="$LLDPQ_DIR/.last_monitor_trigger_check"
ASSETS_LAST_CHECK_FILE="$LLDPQ_DIR/.last_assets_trigger_check"

while true; do
    # Check LLDP trigger
    LLDP_LAST_CHECK=0
    if [ -f "$LLDP_LAST_CHECK_FILE" ]; then
        LLDP_LAST_CHECK=$(cat "$LLDP_LAST_CHECK_FILE")
    fi

    if [ -f "$LLDP_TRIGGER_FILE" ]; then
        LLDP_TRIGGER_TIME=$(stat -c %Y "$LLDP_TRIGGER_FILE" 2>/dev/null || stat -f %m "$LLDP_TRIGGER_FILE" 2>/dev/null || echo 0)
        
        if [ "$LLDP_TRIGGER_TIME" -gt "$LLDP_LAST_CHECK" ]; then
            if [ -f "$LLDP_LOCK_FILE" ] && kill -0 "$(cat "$LLDP_LOCK_FILE")" 2>/dev/null; then
                : # LLDP check already running, skipping trigger
            else
                {                    
                    echo $$ > "$LLDP_LOCK_FILE"
                    echo "$LLDP_TRIGGER_TIME" > "$LLDP_LAST_CHECK_FILE"
                    cd "$LLDPQ_DIR"

                    wait_until_not_running "./assets.sh"
                    ./assets.sh >/dev/null 2>&1
                    wait_until_not_running "./check-lldp.sh"
                    ./check-lldp.sh >/dev/null 2>&1
                    
                    rm -f "$LLDP_LOCK_FILE"
                }
            fi
        fi
    fi

    # Check Monitor trigger
    MONITOR_LAST_CHECK=0
    if [ -f "$MONITOR_LAST_CHECK_FILE" ]; then
        MONITOR_LAST_CHECK=$(cat "$MONITOR_LAST_CHECK_FILE")
    fi

    if [ -f "$MONITOR_TRIGGER_FILE" ]; then
        MONITOR_TRIGGER_TIME=$(stat -c %Y "$MONITOR_TRIGGER_FILE" 2>/dev/null || stat -f %m "$MONITOR_TRIGGER_FILE" 2>/dev/null || echo 0)
        
        if [ "$MONITOR_TRIGGER_TIME" -gt "$MONITOR_LAST_CHECK" ]; then
            echo "$MONITOR_TRIGGER_TIME" > "$MONITOR_LAST_CHECK_FILE"
            cd "$LLDPQ_DIR"
            while pgrep -f "./monitor\.sh" >/dev/null; do
                sleep 2
            done
            ./monitor.sh >/dev/null 2>&1
        fi
    fi

    # Check Assets trigger
    ASSETS_LAST_CHECK=0
    if [ -f "$ASSETS_LAST_CHECK_FILE" ]; then
        ASSETS_LAST_CHECK=$(cat "$ASSETS_LAST_CHECK_FILE")
    fi

    if [ -f "$ASSETS_TRIGGER_FILE" ]; then
        ASSETS_TRIGGER_TIME=$(stat -c %Y "$ASSETS_TRIGGER_FILE" 2>/dev/null || stat -f %m "$ASSETS_TRIGGER_FILE" 2>/dev/null || echo 0)
        
        if [ "$ASSETS_TRIGGER_TIME" -gt "$ASSETS_LAST_CHECK" ]; then
            if [ -f "$ASSETS_LOCK_FILE" ] && kill -0 "$(cat "$ASSETS_LOCK_FILE")" 2>/dev/null; then
                : # Assets refresh already running, skipping trigger
            else
                {
                    echo $$ > "$ASSETS_LOCK_FILE"
                    echo "$ASSETS_TRIGGER_TIME" > "$ASSETS_LAST_CHECK_FILE"
                    cd "$LLDPQ_DIR"
                    wait_until_not_running "./assets.sh"
                    ./assets.sh >/dev/null 2>&1
                    rm -f "$ASSETS_LOCK_FILE"
                }
            fi
        fi
    fi
    
    # Sleep for 3 seconds before next check
    sleep 3
done