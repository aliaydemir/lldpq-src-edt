#!/usr/bin/env bash
# LLDPq Network Monitoring - Parallel Ping Utility
# Copyright (c) 2024 LLDPq Project - Licensed under MIT License
#
# Ali Aydemir
# v11.0 Default to devices.yaml, improved quoting and cleanup
# v10.0 Added parallel execution support for faster ping operations
# v9.9 Updated to support hostname and IP pair input format

count=1       # quantity of send
timeout=0.3   # timeout in seconds (300 milliseconds)
max_tries=3   # if not reachable, quantity of tries (reduced for speed)

starting_time=0
hosts_up=0
hosts_down=0
unreachable_hosts=()
reachable_hosts=()
temp_results=""

# Cleanup on exit or interrupt
cleanup() {
    [[ -n "$temp_results" && -f "$temp_results" ]] && rm -f "$temp_results"
}
trap cleanup EXIT INT TERM

# Find LLDPQ directory
find_lldpq_dir() {
    # Try config file first
    if [[ -f /etc/lldpq.conf ]]; then
        source /etc/lldpq.conf 2>/dev/null
    fi
    LLDPQ_DIR="${LLDPQ_DIR:-$HOME/lldpq}"
}

# Initialize LLDPQ_DIR early for help message
find_lldpq_dir

show_usage() {
    echo -e "\e[95m┌─────────────────────────────────────────────┐\e[0m"
    echo -e "\e[95m│\e[0m            \e[93mPPING v11.0\e[0m                      \e[95m│\e[0m"
    echo -e "\e[95m│\e[0m      \e[92mParallel Ping Utility\e[0m                  \e[95m│\e[0m"
    echo -e "\e[95m└─────────────────────────────────────────────┘\e[0m"
    echo ""
    echo -e "\e[96mUSAGE:\e[0m"
    echo -e "  \e[32mpping\e[0m [\e[33mOPTIONS\e[0m]"
    echo ""
    echo -e "\e[96mOPTIONS:\e[0m"
    echo -e "  \e[33m-f <file>\e[0m     Use custom IP list file instead of devices.yaml"
    echo -e "  \e[33m-v <vrf>\e[0m      Use VRF for ping commands"
    echo -e "  \e[33m-h, --help\e[0m    Show this help message"
    echo ""
    echo -e "\e[96mDEFAULT:\e[0m"
    echo -e "  Uses \e[33m$LLDPQ_DIR/devices.yaml\e[0m"
    echo ""
    echo -e "\e[96mCUSTOM FILE FORMAT (-f):\e[0m"
    echo -e "  Each line: \e[33mhostname ip_address\e[0m  or just  \e[33mip_address\e[0m"
    echo -e "  Lines starting with # are ignored (comments)"
    echo ""
    echo -e "  \e[90mExample file content:\e[0m"
    echo -e "  \e[90m# My servers\e[0m"
    echo -e "  \e[90mswitch1 10.0.0.1\e[0m"
    echo -e "  \e[90mswitch2 10.0.0.2\e[0m"
    echo -e "  \e[90m192.168.1.1\e[0m"
    echo ""
    echo -e "\e[96mEXAMPLES:\e[0m"
    echo -e "  \e[32mpping\e[0m                    # Use devices.yaml (default)"
    echo -e "  \e[32mpping -f custom.txt\e[0m      # Use custom file"
    echo -e "  \e[32mpping -v mgmt\e[0m            # Use mgmt VRF"
    echo ""
    echo -e "\e[96mFEATURES:\e[0m"
    echo -e "  • \e[92mParallel execution\e[0m for faster results"
    echo -e "  • \e[92m300ms timeout\e[0m per ping (3 retries)"
    echo -e "  • \e[92mColor-coded output\e[0m for easy reading"
    echo -e "  • \e[92mInteractive mode\e[0m with repeat option"
    echo ""
}

load_from_devices_yaml() {
    find_lldpq_dir
    local parser="$LLDPQ_DIR/parse_devices.py"
    local yaml_file="$LLDPQ_DIR/devices.yaml"
    
    if [[ ! -f "$yaml_file" ]]; then
        echo -e "\e[91mError: devices.yaml not found at $yaml_file\e[0m"
        echo -e "\e[91mUse: \e[32mpping -f <file>\e[0m to specify a custom file"
        exit 1
    fi
    
    if [[ ! -f "$parser" ]]; then
        echo -e "\e[91mError: parse_devices.py not found at $parser\e[0m"
        exit 1
    fi
    
    # Parse devices.yaml and convert to ip_list format
    eval "$(python3 "$parser")"
    
    if [[ ${#devices[@]} -eq 0 ]]; then
        echo -e "\e[91mError: No devices found in devices.yaml\e[0m"
        exit 1
    fi
    
    ip_list=()
    for ip in "${!devices[@]}"; do
        IFS=' ' read -r user hostname <<< "${devices[$ip]}"
        ip_list+=("$hostname $ip")
    done
    
    echo -e "\e[32mLoaded ${#ip_list[@]} devices from devices.yaml\e[0m"
}

load_ip_list() {
    local file_path="$1"
    if [[ ! -f "$file_path" ]]; then
        echo -e "\e[91mError: \e[32m${file_path}\e[91m does not exist.\e[0m"
        echo -e "\e[91mUse: \e[32mpping -h\e[0m for help"
        exit 1
    fi
    
    ip_list=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        if [[ $(echo "$line" | awk '{print NF}') -eq 2 ]]; then
            ip_list+=("$line")
        else
            ip_list+=("$line $line")
        fi
    done < "$file_path"
    
    echo -e "\e[32mLoaded ${#ip_list[@]} hosts from $file_path\e[0m"
}

command_maker() {
    local entries=("$@")
    local vrf="$vrf_name"
    commands=()
    for entry in "${entries[@]}"; do
        hostname=$(echo "$entry" | cut -d' ' -f1)
        ip=$(echo "$entry" | cut -d' ' -f2)
        if [[ -n "$vrf" ]]; then
            command="timeout $timeout vrf task exec $vrf ping -c$count $ip"
        else
            command="timeout $timeout ping -c$count $ip"
        fi
        commands+=("$command")
    done
}

process_ping() {
    local hostname="$1"
    local cmd="$2"
    local ip="$3"
    local temp_file="$4"
    local tries=0
    
    while [[ $tries -lt $max_tries ]]; do
        tries=$((tries+1))
        if eval "$cmd" > /dev/null 2>&1; then
            echo -e "\e[93m${hostname} [${ip}] is UP\e[0m"
            echo "UP:$hostname $ip" >> "$temp_file"
            return 0
        else
            echo -e "\e[96m${hostname} [${ip}] is DOWN !!!\e[0m"
        fi
    done
    echo "DOWN:$hostname $ip" >> "$temp_file"
    return 1
}

full_ping() {
    echo
    echo -e "\e[101;93m...::Parallel Ping Starting::...\e[0m"
    starting_time=$(date +%s)
    hosts_up=0
    hosts_down=0
    unreachable_hosts=()
    reachable_hosts=()
    
    # Create temporary file for collecting results (global for cleanup trap)
    temp_results=$(mktemp)
    local pids=()
    
    command_maker "${ip_list[@]}"
    
    echo -e "\e[32mStarting parallel ping to ${#ip_list[@]} hosts...\e[0m"
    
    # Start all pings in parallel
    for i in "${!commands[@]}"; do
        local cmd="${commands[i]}"
        local hostname=$(echo "${ip_list[i]}" | cut -d' ' -f1)
        local ip=$(echo "${ip_list[i]}" | cut -d' ' -f2)
        
        if [[ -n "$vrf_name" ]]; then
            echo -e "\e[32mPinging:\e[0m \e[1m${hostname} [${ip}] [VRF: ${vrf_name}]\e[0m"
        else
            echo -e "\e[32mPinging:\e[0m \e[1m${hostname} [${ip}]\e[0m"
        fi
        
        # Start ping in background
        process_ping "$hostname" "$cmd" "$ip" "$temp_results" &
        pids+=($!)
    done
    
    echo
    echo -e "\e[33mWaiting for all pings to complete...\e[0m"
    
    # Wait for all background processes
    for pid in "${pids[@]}"; do
        wait "$pid"
    done
    
    # Process results from temp file
    while IFS=':' read -r status host_info; do
        if [[ "$status" == "UP" ]]; then
            hosts_up=$((hosts_up+1))
            reachable_hosts+=("$host_info")
        elif [[ "$status" == "DOWN" ]]; then
            hosts_down=$((hosts_down+1))
            unreachable_hosts+=("$host_info")
        fi
    done < "$temp_results"
    
    # Cleanup temp file
    rm -f "$temp_results"
    temp_results=""
}

last_call() {
    echo
    echo -e "\e[101;93m...::Ping Completed::...\e[0m"
    elapsed_time=$(($(date +%s) - starting_time))
    echo -e "Time Elapsed: \e[95m${elapsed_time}\e[0m seconds"
    echo -e "Hosts UP: \e[93m${hosts_up}\e[0m, Hosts DOWN: \e[96m${hosts_down}\e[0m"
    if [[ ${#reachable_hosts[@]} -gt 0 ]]; then
        echo -e "\n\e[92mReachable Hosts:\n\e[0m"
        for host in "${reachable_hosts[@]}"; do
            IFS=' ' read -r hostname ip <<< "$host"
            echo -e "\e[32m[$ip] \e[0;32m[$hostname]\e[0m"
        done
        echo ""
    fi
    if [[ ${#unreachable_hosts[@]} -gt 0 ]]; then
        echo -e "\n\e[96mUnreachable Hosts:\n\e[0m"
        for host in "${unreachable_hosts[@]}"; do
            IFS=' ' read -r hostname ip <<< "$host"
            echo -e "\e[31m[$ip] \e[0;31m[$hostname]\e[0m"
        done
        echo ""
    fi
    echo -e "Press \e[32m[P] \e[0mto do it again.\nPress \e[91m[Q] \e[0mto exit."
    read -rsn1 char
    if [[ $char == 'p' || $char == 'P' ]]; then
        main_loop
    elif [[ $char == 'q' || $char == 'Q' ]]; then
        exit 0
    else
        exit 0
    fi
}

main_loop() {
    while true; do
        main "$@"
        last_call
    done
}

main() {
    # Handle --help first
    for arg in "$@"; do
        if [[ "$arg" == "--help" ]]; then
            show_usage
            exit 0
        fi
    done
    
    local file_path=""
    
    while getopts ":v:f:h" opt; do
        case $opt in
            v) vrf_name="$OPTARG" ;;
            f) file_path="$OPTARG" ;;
            h) show_usage; exit 0 ;;
            \?) echo -e "\e[91mInvalid option: -$OPTARG\e[0m" >&2
                echo -e "\e[91mUse: \e[32mpping -h\e[0m for help" >&2
                exit 1 ;;
        esac
    done
    
    # Load hosts: custom file if specified, otherwise devices.yaml
    if [[ -n "$file_path" ]]; then
        load_ip_list "$file_path"
    else
        load_from_devices_yaml
    fi
    
    full_ping
}

main_loop "$@"