<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>..::LLDPQ::..</title>
    <link rel="shortcut icon" href="/png/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            min-height: 100vh;
        }
        
        /* Page Header */
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #404040;
        }
        
        .page-title {
            font-size: 24px;
            font-weight: 600;
            color: #76b900;
        }
        
        /* Global Search */
        .global-search-container {
            margin-bottom: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
            border-radius: 8px;
            border: 1px solid #404040;
        }
        
        .global-search-box {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .global-search-box input {
            flex: 1;
            padding: 12px 16px;
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 15px;
        }
        
        .global-search-box input:focus {
            outline: none;
            border-color: #76b900;
        }
        
        .global-search-box input::placeholder {
            color: #666;
        }
        
        .search-buttons {
            display: flex;
            gap: 8px;
        }
        
        .btn-search {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            background: #76b900;
            color: #000;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .btn-search:hover {
            background: #8ed600;
            transform: translateY(-1px);
        }
        
        .btn-clear {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            background: #3a3a3a;
            color: #ccc;
            border: 1px solid #555;
            border-radius: 6px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
        }
        
        .btn-scan {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 12px 16px;
            background: #2d4a1c;
            color: #76b900;
            border: 1px solid #76b900;
            border-radius: 6px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn-scan:hover {
            background: #3d5a2c;
        }
        
        .btn-scan:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .scan-status {
            font-size: 13px;
            color: #888;
            padding: 8px 12px;
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #404040;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .btn-clear:hover {
            background: #4a4a4a;
            color: #fff;
        }
        
        .global-search-results {
            margin-top: 15px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .global-result-section {
            margin-bottom: 15px;
        }
        
        .global-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #333;
            border-radius: 4px 4px 0 0;
            font-weight: 600;
            color: var(--primary-green);
        }
        
        .last-updated {
            font-size: 13px;
            color: #888;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: #2d2d2d;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }
        
        .tab {
            padding: 14px 24px;
            background: #333;
            border: none;
            color: #888;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tab:hover {
            background: #3a3a3a;
            color: #d4d4d4;
        }
        
        .tab.active {
            background: #2d2d2d;
            color: #76b900;
            border-bottom: 2px solid #76b900;
        }
        
        /* Dashboard Section */
        .dashboard-section {
            background: #2d2d2d;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .section-content {
            padding: 20px;
        }
        
        /* Search Form */
        .search-container {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .device-select {
            padding: 10px 14px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #3c3c3c;
            color: #d4d4d4;
            font-size: 13px;
            min-width: 200px;
        }
        
        .device-select:focus {
            outline: none;
            border-color: #76b900;
        }
        
        .search-input {
            padding: 10px 14px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #3c3c3c;
            color: #d4d4d4;
            font-size: 13px;
            min-width: 300px;
            flex: 1;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #76b900;
        }
        
        .search-input::placeholder {
            color: #888;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(0deg, #76b900 0%, #5a8c00 100%);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(0deg, #8bd400 0%, #6ba000 100%);
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: #404040;
            color: #d4d4d4;
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        /* Results Container */
        .results-container {
            background: #2d2d2d;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .results-header {
            padding: 12px 16px;
            background: #333;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .results-title {
            font-weight: 600;
            font-size: 14px;
            color: #76b900;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .search-stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #888;
        }
        
        .results-content {
            padding: 0;
            min-height: 150px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        /* Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .data-table th, .data-table td {
            padding: 10px 14px;
            text-align: left;
            border-bottom: 1px solid #404040;
        }
        
        .data-table th {
            background: #333;
            color: #76b900;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        
        .data-table th:hover {
            background: #3a3a3a;
        }
        
        .data-table th .sort-icon {
            margin-left: 5px;
            opacity: 0.5;
            font-size: 10px;
        }
        
        .data-table th.sort-asc .sort-icon::after { content: '▲'; opacity: 1; }
        .data-table th.sort-desc .sort-icon::after { content: '▼'; opacity: 1; }
        .data-table th:not(.sort-asc):not(.sort-desc) .sort-icon::after { content: '⇅'; }
        
        .data-table th.text-right,
        .data-table td.text-right {
            text-align: right;
        }
        
        .data-table tr:hover {
            background: #353535;
        }
        
        .data-table td.mac {
            font-family: 'Fira Code', 'Courier New', monospace;
            color: #4fc3f7;
        }
        
        .data-table td.ip {
            font-family: 'Fira Code', 'Courier New', monospace;
            color: #81c784;
        }
        
        .data-table td.device {
            color: #ffb74d;
        }
        
        /* Messages */
        .status-message {
            text-align: center;
            padding: 40px 20px;
            color: #888;
        }
        
        .loading-message {
            text-align: center;
            padding: 40px 20px;
            color: #76b900;
        }
        
        .error-message {
            text-align: center;
            padding: 20px;
            color: #ff6b6b;
            background: rgba(244, 67, 54, 0.1);
            margin: 10px;
            border-radius: 6px;
        }
        
        /* VRF Tabs at top of route table */
        .vrf-tabs-container {
            padding: 10px 14px;
            background: #2a2a2a;
            border-bottom: 1px solid #404040;
        }
        
        .vrf-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .vrf-tab {
            padding: 6px 14px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #aaa;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .vrf-tab:hover {
            background: #3a3a3a;
            border-color: #555;
        }
        
        .vrf-tab.active {
            background: var(--primary-green);
            color: #1a1a1a;
            border-color: var(--primary-green);
            font-weight: 600;
        }
        
        .vrf-tab .route-count {
            margin-left: 6px;
            font-size: 11px;
            opacity: 0.7;
        }
        
        /* VRF Sections for Route Table */
        .vrf-section {
            margin-bottom: 20px;
        }
        
        .vrf-section .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #2a2a2a;
            border-radius: 6px 6px 0 0;
            border-bottom: 2px solid var(--primary-green);
            position: sticky;
            top: 0;
            z-index: 20;
        }
        
        .vrf-section .section-title {
            font-weight: 600;
            font-size: 14px;
        }
        
        .vrf-section .result-count {
            color: #888;
            font-size: 12px;
        }
        
        /* Badges */
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }
        
        .badge-cyan { background: rgba(0, 188, 212, 0.2); color: #4dd0e1; }
        .badge-green { background: rgba(118, 185, 0, 0.2); color: #76b900; }
        .badge-blue { background: rgba(33, 150, 243, 0.2); color: #64b5f6; }
        .badge-purple { background: rgba(156, 39, 176, 0.2); color: #ce93d8; }
        .badge-orange { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }
        .badge-gray { background: rgba(158, 158, 158, 0.2); color: #9e9e9e; }
        .badge-pink { background: rgba(233, 30, 99, 0.2); color: #f48fb1; }
        
        .badge-green {
            background: rgba(118, 185, 0, 0.2);
            color: #76b900;
        }
        
        .badge-orange {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }
        
        /* Config Search Results */
        .device-result {
            margin: 10px;
            padding: 15px;
            background: #252526;
            border-left: 3px solid #76b900;
            border-radius: 6px;
        }
        
        .device-result h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #76b900;
        }
        
        .match-line {
            background: #1e1e1e;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 2px solid #404040;
            overflow-x: auto;
            font-size: 12px;
            font-family: 'Fira Code', 'Courier New', monospace;
        }
        
        .green { color: #76b900; font-weight: bold; }
        
        /* Tab content */
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Badge */
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .badge-state-REACHABLE { background: #4caf50; color: #fff; }
        .badge-state-STALE { background: #ff9800; color: #000; }
        .badge-state-PERMANENT { background: #2196f3; color: #fff; }
        .badge-state-DELAY, .badge-state-PROBE { background: #9c27b0; color: #fff; }
        .badge-state-FAILED { background: #f44336; color: #fff; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    <!-- Page Header -->
    <div class="page-header">
        <div>
            <div class="page-title">Fabric Search</div>
            <div class="last-updated">Last Updated: <span id="last-updated"></span></div>
        </div>
        <div id="scanStatus" class="scan-status"></div>
    </div>
    
    <!-- Global Search -->
    <div class="global-search-container">
        <div class="global-search-box">
            <input type="text" id="globalSearchInput" placeholder="Search IP or MAC across all devices..." 
                   onkeydown="if(event.key==='Enter') globalSearch()">
            <div class="search-buttons">
                <button class="btn-search" onclick="globalSearch()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/>
                    </svg>
                    Search All
                </button>
                <button class="btn-clear" onclick="clearGlobalSearch()">Clear</button>
            </div>
        </div>
        <div id="globalSearchResults" class="global-search-results" style="display: none;"></div>
    </div>
    
    <!-- Tabs -->
    <div class="tabs">
        <button class="tab active" onclick="switchTab('mac')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M4 1h16a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1m0 8h16a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1m0 8h16a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1z"/>
            </svg>
            MAC
        </button>
        <button class="tab" onclick="switchTab('arp')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            </svg>
            ARP
        </button>
        <button class="tab" onclick="switchTab('vtep')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
            </svg>
            VTEP
        </button>
        <button class="tab" onclick="switchTab('route')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"/>
            </svg>
            Routes
        </button>
        <button class="tab" onclick="switchTab('lldp')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
            </svg>
            LLDP
        </button>
    </div>
    
    <!-- MAC Table Tab -->
    <div id="tab-mac" class="tab-content active">
        <div class="dashboard-section">
            <div class="section-content">
                <div class="search-container">
                    <select id="macDeviceSelect" class="device-select" onchange="loadMacTable()">
                        <option value="">All Devices</option>
                    </select>
                    <input type="text" id="macSearchInput" class="search-input" placeholder="Filter by MAC address or interface..." />
                    <button onclick="loadMacTable()" class="btn btn-primary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                        </svg>
                        Load
                    </button>
                    <button onclick="clearTabResults('mac')" class="btn btn-secondary">Clear</button>
                    <button onclick="exportTable('mac')" class="btn btn-secondary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M12,19L8,15H10.5V12H13.5V15H16L12,19Z"/>
                        </svg>
                        CSV
                    </button>
                </div>
            </div>
        </div>
        <div id="macResults" class="results-container">
            <div class="results-header">
                <div class="results-title">MAC Address Table</div>
                <div class="search-stats">
                    <span id="macResultCount">Select a device or click Load</span>
                </div>
            </div>
            <div id="macResultsContent" class="results-content">
                <div class="status-message">Select a device and click Load to view MAC table</div>
            </div>
        </div>
    </div>
    
    <!-- ARP Table Tab -->
    <div id="tab-arp" class="tab-content">
        <div class="dashboard-section">
            <div class="section-content">
                <div class="search-container">
                    <select id="arpDeviceSelect" class="device-select" onchange="loadArpTable()">
                        <option value="">All Devices</option>
                    </select>
                    <input type="text" id="arpSearchInput" class="search-input" placeholder="Filter by IP, MAC, or interface..." />
                    <button onclick="loadArpTable()" class="btn btn-primary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                        </svg>
                        Load
                    </button>
                    <button onclick="clearTabResults('arp')" class="btn btn-secondary">Clear</button>
                    <button onclick="exportTable('arp')" class="btn btn-secondary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M12,19L8,15H10.5V12H13.5V15H16L12,19Z"/>
                        </svg>
                        CSV
                    </button>
                </div>
            </div>
        </div>
        <div id="arpResults" class="results-container">
            <div class="results-header">
                <div class="results-title">ARP/Neighbor Table</div>
                <div class="search-stats">
                    <span id="arpResultCount">Select a device or click Load</span>
                </div>
            </div>
            <div id="arpResultsContent" class="results-content">
                <div class="status-message">Select a device and click Load to view ARP table</div>
            </div>
        </div>
    </div>
    
    <!-- VTEP Table Tab -->
    <div id="tab-vtep" class="tab-content">
        <div class="dashboard-section">
            <div class="section-content">
                <div class="search-container">
                    <select id="vtepDeviceSelect" class="device-select">
                        <option value="">Select Device</option>
                    </select>
                    <input type="text" id="vtepSearchInput" class="search-input" placeholder="Filter by VTEP IP or VNI..." />
                    <button onclick="loadVtepTable()" class="btn btn-primary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                        </svg>
                        Load
                    </button>
                    <button onclick="clearTabResults('vtep')" class="btn btn-secondary">Clear</button>
                </div>
            </div>
        </div>
        <div id="vtepResults" class="results-container">
            <div class="results-header">
                <div class="results-title">VXLAN Remote VTEPs</div>
                <div class="search-stats">
                    <span id="vtepResultCount">Select a device and click Load</span>
                </div>
            </div>
            <div id="vtepResultsContent" class="results-content">
                <div class="status-message">Select a device and click Load to view remote VTEPs</div>
            </div>
        </div>
    </div>
    
    <!-- Route Table Tab -->
    <div id="tab-route" class="tab-content">
        <div class="dashboard-section">
            <div class="section-content">
                <div class="search-container">
                    <select id="routeDeviceSelect" class="device-select">
                        <option value="">Select Device</option>
                    </select>
                    <input type="text" id="routeSearchInput" class="search-input" placeholder="Filter by prefix, nexthop, or VRF..." />
                    <button onclick="loadRouteTable()" class="btn btn-primary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                        </svg>
                        Load
                    </button>
                    <button onclick="clearTabResults('route')" class="btn btn-secondary">Clear</button>
                </div>
            </div>
        </div>
        <div id="routeResults" class="results-container">
            <div class="results-header">
                <div class="results-title">Routing Table</div>
                <div class="search-stats">
                    <span id="routeResultCount">Select a device and click Load</span>
                </div>
            </div>
            <div id="vrfTabsContainer" class="vrf-tabs-container" style="display: none;">
                <div class="vrf-tabs" id="vrfTabs"></div>
            </div>
            <div id="routeResultsContent" class="results-content">
                <div class="status-message">Select a device and click Load to view routes</div>
            </div>
        </div>
    </div>
    
    <!-- LLDP Neighbors Tab -->
    <div id="tab-lldp" class="tab-content">
        <div class="dashboard-section">
            <div class="section-content">
                <div class="search-container">
                    <select id="lldpDeviceSelect" class="device-select">
                        <option value="">Select Device</option>
                    </select>
                    <input type="text" id="lldpSearchInput" class="search-input" placeholder="Filter by neighbor or port..." />
                    <button onclick="loadLldpNeighbors()" class="btn btn-primary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                        </svg>
                        Load
                    </button>
                    <button onclick="clearTabResults('lldp')" class="btn btn-secondary">Clear</button>
                </div>
            </div>
        </div>
        <div id="lldpResults" class="results-container">
            <div class="results-header">
                <div class="results-title">LLDP Neighbors</div>
                <div class="search-stats">
                    <span id="lldpResultCount">Select a device and click Load</span>
                </div>
            </div>
            <div id="lldpResultsContent" class="results-content">
                <div class="status-message">Select a device and click Load to view LLDP neighbors</div>
            </div>
        </div>
    </div>

    <script>
        let currentMacData = [];
        let currentArpData = [];
        
        function setLastUpdated() {
            const now = new Date();
            const options = { 
                year: 'numeric', month: '2-digit', day: '2-digit', 
                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
            };
            document.getElementById('last-updated').textContent = now.toLocaleString('en-US', options);
        }
        
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.closest('.tab').classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('tab-' + tabName).classList.add('active');
        }
        
        // Table sorting function
        function sortTable(table, colIndex, isNumeric = false) {
            const tbody = table.querySelector('tbody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const th = table.querySelectorAll('th')[colIndex];
            
            // Determine sort direction
            const isAsc = th.classList.contains('sort-asc');
            
            // Remove sort classes from all headers
            table.querySelectorAll('th').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Set new sort direction
            if (isAsc) {
                th.classList.add('sort-desc');
            } else {
                th.classList.add('sort-asc');
            }
            
            const direction = isAsc ? -1 : 1;
            
            rows.sort((a, b) => {
                let aVal = a.cells[colIndex]?.textContent.trim() || '';
                let bVal = b.cells[colIndex]?.textContent.trim() || '';
                
                // Handle numeric sorting
                if (isNumeric) {
                    aVal = parseFloat(aVal.replace(/[^\d.-]/g, '')) || 0;
                    bVal = parseFloat(bVal.replace(/[^\d.-]/g, '')) || 0;
                    return (aVal - bVal) * direction;
                }
                
                // Handle IP address sorting
                const ipRegex = /^(\d+)\.(\d+)\.(\d+)\.(\d+)/;
                const aMatch = aVal.match(ipRegex);
                const bMatch = bVal.match(ipRegex);
                if (aMatch && bMatch) {
                    for (let i = 1; i <= 4; i++) {
                        const diff = parseInt(aMatch[i]) - parseInt(bMatch[i]);
                        if (diff !== 0) return diff * direction;
                    }
                    return 0;
                }
                
                // String sorting
                return aVal.localeCompare(bVal) * direction;
            });
            
            rows.forEach(row => tbody.appendChild(row));
        }
        
        function attachSortHandlers(table) {
            const headers = table.querySelectorAll('th');
            headers.forEach((th, index) => {
                th.addEventListener('click', () => {
                    const isNumeric = th.dataset.numeric === 'true';
                    sortTable(table, index, isNumeric);
                });
            });
        }
        
        // Load device list for dropdowns
        async function loadDeviceList() {
            try {
                const response = await fetch('search-api.sh?action=list-devices');
                const data = await response.json();
                
                if (data.success && data.devices) {
                    const selects = ['macDeviceSelect', 'arpDeviceSelect', 'vtepDeviceSelect', 'routeDeviceSelect', 'lldpDeviceSelect'];
                    
                    selects.forEach(selectId => {
                        const select = document.getElementById(selectId);
                        if (select) {
                            data.devices.forEach(device => {
                                select.add(new Option(device.hostname, device.ip));
                            });
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to load device list:', error);
            }
        }
        
        // ============ MAC TABLE ============
        async function loadMacTable() {
            const device = document.getElementById('macDeviceSelect').value;
            const search = document.getElementById('macSearchInput').value.trim();
            const results = document.getElementById('macResultsContent');
            const resultCount = document.getElementById('macResultCount');
            
            results.innerHTML = '<div class="loading-message">Loading MAC table...</div>';
            
            try {
                // Use cached data for "All Devices", live for single device
                const action = device ? 'get-mac' : 'search-cached-mac';
                const url = 'search-api.sh?action=' + action + 
                            (device ? '&device=' + encodeURIComponent(device) : '') +
                            (search ? '&search=' + encodeURIComponent(search) : '');
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    // Filter out vxlan interfaces (remote learned MACs)
                    let entries = data.entries.filter(e => !e.interface || !e.interface.startsWith('vxlan'));
                    currentMacData = entries;
                    resultCount.textContent = entries.length + ' of ' + data.total + ' entries';
                    
                    if (entries.length === 0) {
                        results.innerHTML = '<div class="status-message">No local MAC entries found (vxlan filtered)</div>';
                        return;
                    }
                    
                    let html = '<table class="data-table" id="macTable"><thead><tr>';
                    if (!device) html += '<th>Device<span class="sort-icon"></span></th>';
                    html += '<th>MAC Address<span class="sort-icon"></span></th>';
                    html += '<th>Interface<span class="sort-icon"></span></th>';
                    html += '<th>Physical Ports<span class="sort-icon"></span></th>';
                    html += '<th class="text-right" data-numeric="true">VLAN<span class="sort-icon"></span></th></tr></thead><tbody>';
                    
                    entries.forEach(entry => {
                        const bondPorts = entry.bond_ports ? entry.bond_ports.join(', ') : '';
                        html += '<tr>';
                        if (!device) html += '<td class="device">' + (entry.device || '-') + '</td>';
                        html += '<td class="mac">' + entry.mac + '</td>';
                        html += '<td>' + (entry.interface || '-') + '</td>';
                        html += '<td style="color: #4fc3f7;">' + bondPorts + '</td>';
                        html += '<td class="text-right">' + (entry.vlan || '-') + '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    results.innerHTML = html;
                    attachSortHandlers(document.getElementById('macTable'));
                } else {
                    results.innerHTML = '<div class="error-message">' + (data.error || 'Failed to load') + '</div>';
                }
            } catch (e) {
                results.innerHTML = '<div class="error-message">Error: ' + e.message + '</div>';
            }
        }
        
        // ============ ARP TABLE ============
        async function loadArpTable() {
            const device = document.getElementById('arpDeviceSelect').value;
            const search = document.getElementById('arpSearchInput').value.trim();
            const results = document.getElementById('arpResultsContent');
            const resultCount = document.getElementById('arpResultCount');
            
            results.innerHTML = '<div class="loading-message">Loading ARP table...</div>';
            
            try {
                // Use cached data for "All Devices", live for single device
                const action = device ? 'get-arp' : 'search-cached-arp';
                const url = 'search-api.sh?action=' + action + 
                            (device ? '&device=' + encodeURIComponent(device) : '') +
                            (search ? '&search=' + encodeURIComponent(search) : '');
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    currentArpData = data.entries;
                    resultCount.textContent = data.entries.length + ' of ' + data.total + ' entries';
                    
                    if (data.entries.length === 0) {
                        results.innerHTML = '<div class="status-message">No ARP entries found</div>';
                        return;
                    }
                    
                    let html = '<table class="data-table" id="arpTable"><thead><tr>';
                    if (!device) html += '<th>Device<span class="sort-icon"></span></th>';
                    html += '<th>IP Address<span class="sort-icon"></span></th>';
                    html += '<th>MAC Address<span class="sort-icon"></span></th>';
                    html += '<th>Interface<span class="sort-icon"></span></th>';
                    html += '<th>VRF<span class="sort-icon"></span></th>';
                    html += '<th class="text-right">State<span class="sort-icon"></span></th></tr></thead><tbody>';
                    
                    data.entries.forEach(entry => {
                        const stateClass = entry.state ? 'badge badge-state-' + entry.state : '';
                        html += '<tr>';
                        if (!device) html += '<td class="device">' + (entry.device || '-') + '</td>';
                        html += '<td class="ip">' + entry.ip + '</td>';
                        html += '<td class="mac">' + entry.mac + '</td>';
                        html += '<td>' + (entry.interface || '-') + '</td>';
                        html += '<td>' + (entry.vrf || 'default') + '</td>';
                        html += '<td class="text-right"><span class="' + stateClass + '">' + (entry.state || '-') + '</span></td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    results.innerHTML = html;
                    attachSortHandlers(document.getElementById('arpTable'));
                } else {
                    results.innerHTML = '<div class="error-message">' + (data.error || 'Failed to load') + '</div>';
                }
            } catch (e) {
                results.innerHTML = '<div class="error-message">Error: ' + e.message + '</div>';
            }
        }
        
        // ============ VTEP TABLE ============
        async function loadVtepTable() {
            const device = document.getElementById('vtepDeviceSelect').value;
            const search = document.getElementById('vtepSearchInput').value.trim();
            const results = document.getElementById('vtepResultsContent');
            const resultCount = document.getElementById('vtepResultCount');
            
            if (!device) {
                results.innerHTML = '<div class="error-message">Please select a device</div>';
                return;
            }
            
            results.innerHTML = '<div class="loading-message">Loading VTEP table...</div>';
            
            try {
                const url = 'search-api.sh?action=get-vtep&device=' + encodeURIComponent(device) +
                            (search ? '&search=' + encodeURIComponent(search) : '');
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    const summary = data.summary || {};
                    resultCount.textContent = data.entries.length + ' entries (' + (summary.unique_vteps || 0) + ' VTEPs)';
                    
                    if (data.entries.length === 0) {
                        results.innerHTML = '<div class="status-message">No remote VTEPs found</div>';
                        return;
                    }
                    
                    let html = '<table class="data-table" id="vtepTable"><thead><tr>';
                    html += '<th>Remote VTEP<span class="sort-icon"></span></th>';
                    html += '<th>MAC Address<span class="sort-icon"></span></th>';
                    html += '<th data-numeric="true">VNI<span class="sort-icon"></span></th>';
                    html += '<th>Type<span class="sort-icon"></span></th>';
                    html += '<th>State<span class="sort-icon"></span></th>';
                    html += '<th class="text-right">Interface<span class="sort-icon"></span></th></tr></thead><tbody>';
                    
                    data.entries.forEach(entry => {
                        const typeClass = entry.type === 'BUM' ? 'badge badge-orange' : 'badge badge-cyan';
                        const stateClass = entry.state === 'permanent' ? 'badge badge-green' : 
                                          entry.state === 'offload' ? 'badge badge-cyan' : '';
                        html += '<tr>';
                        html += '<td class="ip">' + entry.vtep + '</td>';
                        html += '<td class="mac">' + (entry.mac || '-') + '</td>';
                        html += '<td>' + (entry.vni || '-') + '</td>';
                        html += '<td><span class="' + typeClass + '">' + (entry.type || '-') + '</span></td>';
                        html += '<td>' + (stateClass ? '<span class="' + stateClass + '">' + entry.state + '</span>' : entry.state || '-') + '</td>';
                        html += '<td class="text-right">' + (entry.interface || '-') + '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    results.innerHTML = html;
                    attachSortHandlers(document.getElementById('vtepTable'));
                } else {
                    results.innerHTML = '<div class="error-message">' + (data.error || 'Failed to load') + '</div>';
                }
            } catch (e) {
                results.innerHTML = '<div class="error-message">Error: ' + e.message + '</div>';
            }
        }
        
        // ============ GLOBAL SEARCH ============
        function clearGlobalSearch() {
            document.getElementById('globalSearchInput').value = '';
            document.getElementById('globalSearchResults').innerHTML = '';
            document.getElementById('globalSearchResults').style.display = 'none';
        }
        
        function clearTabResults(tab) {
            const configs = {
                'mac': { search: 'macSearchInput', results: 'macResultsContent', count: 'macResultCount', msg: 'Select a device and click Load to view MAC table' },
                'arp': { search: 'arpSearchInput', results: 'arpResultsContent', count: 'arpResultCount', msg: 'Select a device and click Load to view ARP table' },
                'vtep': { search: 'vtepSearchInput', results: 'vtepResultsContent', count: 'vtepResultCount', msg: 'Select a device and click Load to view remote VTEPs' },
                'route': { search: 'routeSearchInput', results: 'routeResultsContent', count: 'routeResultCount', msg: 'Select a device and click Load to view routes' },
                'lldp': { search: 'lldpSearchInput', results: 'lldpResultsContent', count: 'lldpResultCount', msg: 'Select a device and click Load to view LLDP neighbors' }
            };
            
            const cfg = configs[tab];
            if (cfg) {
                document.getElementById(cfg.search).value = '';
                document.getElementById(cfg.results).innerHTML = '<div class="status-message">' + cfg.msg + '</div>';
                document.getElementById(cfg.count).textContent = 'Select a device or click Load';
                
                // Hide VRF tabs for route
                if (tab === 'route') {
                    document.getElementById('vrfTabsContainer').style.display = 'none';
                }
            }
        }
        
        async function globalSearch() {
            const searchTerm = document.getElementById('globalSearchInput').value.trim();
            const resultsDiv = document.getElementById('globalSearchResults');
            
            if (!searchTerm || searchTerm.length < 3) {
                resultsDiv.innerHTML = '<div class="status-message">Enter at least 3 characters to search</div>';
                resultsDiv.style.display = 'block';
                return;
            }
            
            resultsDiv.innerHTML = '<div class="loading-message">Searching for "' + searchTerm + '"...</div>';
            resultsDiv.style.display = 'block';
            
            try {
                // Always use cached data (fast) - no need for live SSH queries
                let macData, arpData;
                
                // Detect search type: full IP vs partial/subnet
                const isFullIp = /^(\d{1,3}\.){3}\d{1,3}$/.test(searchTerm);
                const isSubnetSearch = /^\d+\.\d+/.test(searchTerm) && !isFullIp;
                
                const [macResponse, arpResponse] = await Promise.all([
                    fetch('search-api.sh?action=search-cached-mac&search=' + encodeURIComponent(searchTerm)),
                    fetch('search-api.sh?action=search-cached-arp&search=' + encodeURIComponent(searchTerm))
                ]);
                macData = await macResponse.json();
                arpData = await arpResponse.json();
                
                // Filter interfaces - vxlan from MAC, VRR from ARP
                const filterMac = (entries) => entries.filter(e => {
                    if (!e.interface) return true;
                    if (e.interface.startsWith('vxlan')) return false;  // Filter vxlan (remote learned)
                    return true;
                });
                
                const filterArp = (entries) => entries.filter(e => {
                    if (!e.interface) return true;
                    if (e.interface.match(/-v\d+$/)) return false;  // Filter VRR interfaces like vlan80-v0
                    return true;
                });
                
                if (macData.success && macData.entries) {
                    macData.entries = filterMac(macData.entries);
                }
                if (arpData.success && arpData.entries) {
                    arpData.entries = filterArp(arpData.entries);
                }
                
                // Cross-reference: If searching IP, also search for associated MAC
                // If searching MAC, also search for associated IP
                // SKIP for subnet searches (192.168.64) to avoid 100+ sequential API calls
                let crossRefMacs = new Set();
                let crossRefIps = new Set();
                let crossRefInfo = [];
                
                // Check if search term looks like an IP
                const isIpSearch = /^\d+\.\d+\.\d+/.test(searchTerm);
                // Check if search term looks like a MAC
                const isMacSearch = /^[0-9a-f]{2}[:-]?[0-9a-f]{2}/i.test(searchTerm);
                
                if (isIpSearch && !isSubnetSearch && arpData.success && arpData.entries) {
                    // Found IP in ARP, get the associated MAC
                    arpData.entries.forEach(e => {
                        if (e.mac && e.mac !== '00:00:00:00:00:00') {
                            crossRefMacs.add(e.mac);
                            crossRefInfo.push({type: 'ip-to-mac', ip: e.ip, mac: e.mac, device: e.device});
                        }
                    });
                }
                
                if (isMacSearch && arpData.success && arpData.entries) {
                    // Found MAC in ARP, get the associated IP
                    arpData.entries.forEach(e => {
                        if (e.ip) {
                            crossRefIps.add(e.ip);
                            crossRefInfo.push({type: 'mac-to-ip', ip: e.ip, mac: e.mac, device: e.device});
                        }
                    });
                }
                
                // If we found cross-references, search for them too (using cached data)
                let crossRefMacResults = [];
                if (crossRefMacs.size > 0) {
                    for (const mac of crossRefMacs) {
                        try {
                            const resp = await fetch('search-api.sh?action=search-cached-mac&search=' + encodeURIComponent(mac));
                            const data = await resp.json();
                            if (data.success && data.entries) {
                                crossRefMacResults.push(...filterMac(data.entries));
                            }
                        } catch (e) {}
                    }
                }
                
                let html = '';
                let totalResults = 0;
                
                // Cross-reference summary - show only unique IP ↔ MAC pairs
                if (crossRefInfo.length > 0) {
                    // Deduplicate - only show unique IP ↔ MAC mappings
                    const uniqueMappings = new Map();
                    crossRefInfo.forEach(info => {
                        const key = info.type === 'ip-to-mac' ? info.ip + '|' + info.mac : info.mac + '|' + info.ip;
                        if (!uniqueMappings.has(key)) {
                            uniqueMappings.set(key, info);
                        }
                    });
                    
                    // Sort cross-ref by IP (version sort)
                    const sortedMappings = Array.from(uniqueMappings.values()).sort((a, b) => {
                        const pa = (a.ip || '').split('.').map(Number);
                        const pb = (b.ip || '').split('.').map(Number);
                        for (let i = 0; i < 4; i++) {
                            if ((pa[i] || 0) !== (pb[i] || 0)) return (pa[i] || 0) - (pb[i] || 0);
                        }
                        return 0;
                    });
                    
                    html += '<div style="margin-bottom: 12px; padding: 10px 15px; background: linear-gradient(90deg, #2d4a1c, #1e1e1e); border-left: 3px solid #76b900; border-radius: 4px;">';
                    html += '<div style="color: #76b900; font-weight: 600; margin-bottom: 8px;">Cross Reference</div>';
                    sortedMappings.forEach(info => {
                        if (info.type === 'ip-to-mac') {
                            html += '<div style="margin: 3px 0;"><span class="ip">' + info.ip + '</span> <span style="color: #888;">↔</span> <span class="mac">' + info.mac + '</span></div>';
                        } else {
                            html += '<div style="margin: 3px 0;"><span class="mac">' + info.mac + '</span> <span style="color: #888;">↔</span> <span class="ip">' + info.ip + '</span></div>';
                        }
                    });
                    html += '</div>';
                }
                
                // Combine MAC results with cross-reference MAC results
                let allMacEntries = macData.success && macData.entries ? [...macData.entries] : [];
                crossRefMacResults.forEach(e => {
                    if (!allMacEntries.some(x => x.mac === e.mac && x.device === e.device)) {
                        allMacEntries.push(e);
                    }
                });
                
                // Multihoming: Find same bond on ESI peer devices
                // Skip for subnet searches to keep it fast
                const bondInterfaces = new Set();
                const foundMacs = new Set();
                if (isSubnetSearch) { /* skip multihoming for subnet searches */ }
                allMacEntries.forEach(e => {
                    if (e.interface && e.interface.startsWith('bond')) {
                        bondInterfaces.add(e.interface);
                    }
                    foundMacs.add(e.mac + '|' + e.device);
                });
                
                // Search for multihoming peers (same bond on different devices)
                // Skip for subnet searches to keep it fast
                let multihomingPeers = [];
                for (const bondName of (isSubnetSearch ? [] : bondInterfaces)) {
                    try {
                        const resp = await fetch('search-api.sh?action=search-cached-mac&search=' + encodeURIComponent(bondName));
                        const data = await resp.json();
                        if (data.success && data.entries) {
                            // Get devices that have this bond
                            const bondDevices = new Map();
                            data.entries.forEach(e => {
                                if (e.interface === bondName && !e.interface.startsWith('vxlan')) {
                                    if (!bondDevices.has(e.device)) {
                                        bondDevices.set(e.device, { ports: e.bond_ports || [], vlan: e.vlan });
                                    }
                                }
                            });
                            if (bondDevices.size > 1) {
                                multihomingPeers.push({ bond: bondName, devices: bondDevices });
                                
                                // Add peer entries to MAC table if not already there
                                const originalMac = allMacEntries.find(m => m.interface === bondName)?.mac;
                                if (originalMac) {
                                    bondDevices.forEach((info, device) => {
                                        const key = originalMac + '|' + device;
                                        if (!foundMacs.has(key)) {
                                            allMacEntries.push({
                                                device: device,
                                                mac: originalMac,
                                                interface: bondName,
                                                bond_ports: info.ports,
                                                vlan: info.vlan,
                                                peer: true  // Mark as peer entry
                                            });
                                            foundMacs.add(key);
                                        }
                                    });
                                }
                            }
                        }
                    } catch (e) {}
                }
                
                // Show multihoming info
                if (multihomingPeers.length > 0) {
                    html += '<div style="margin-bottom: 12px; padding: 10px 15px; background: linear-gradient(90deg, #1c3d4a, #1e1e1e); border-left: 3px solid #4fc3f7; border-radius: 4px;">';
                    html += '<div style="color: #4fc3f7; font-weight: 600; margin-bottom: 8px;">Multihoming (ESI Peers)</div>';
                    multihomingPeers.forEach(info => {
                        html += '<div style="margin: 5px 0;"><span style="color: #888;">Bond:</span> <span style="color: #fff; font-weight: 500;">' + info.bond + '</span></div>';
                        info.devices.forEach((devInfo, device) => {
                            const portStr = devInfo.ports.length > 0 ? devInfo.ports.join(', ') : '-';
                            html += '<div style="margin: 3px 0 3px 15px;"><span class="device">' + device + '</span> → <span style="color: #4fc3f7;">' + portStr + '</span></div>';
                        });
                    });
                    html += '</div>';
                }
                
                // MAC Results
                if (allMacEntries.length > 0) {
                    totalResults += allMacEntries.length;
                    html += '<div class="global-result-section">';
                    html += '<div class="global-result-header"><span>MAC Table Matches</span><span>' + allMacEntries.length + ' found</span></div>';
                    html += '<table class="data-table" style="table-layout:fixed"><thead><tr>';
                    html += '<th style="width:120px">Device</th><th style="width:150px">MAC Address</th><th style="width:110px">Interface</th><th style="width:130px">Physical Ports</th><th style="width:70px" class="text-right">VLAN</th></tr></thead><tbody>';
                    
                    const entriesToShow = allMacEntries.slice(0, 50);
                    entriesToShow.forEach(entry => {
                        const bondPorts = entry.bond_ports ? entry.bond_ports.join(', ') : '';
                        html += '<tr>';
                        html += '<td class="device">' + (entry.device || '-') + '</td>';
                        html += '<td class="mac">' + entry.mac + '</td>';
                        html += '<td>' + (entry.interface || '-') + '</td>';
                        html += '<td style="color: #4fc3f7;">' + bondPorts + '</td>';
                        html += '<td class="text-right">' + (entry.vlan || '-') + '</td>';
                        html += '</tr>';
                    });
                    html += '</tbody></table></div>';
                }
                
                // ARP Results
                if (arpData.success && arpData.entries && arpData.entries.length > 0) {
                    // Sort by IP address (version/natural sort: 10.1.1.2 before 10.1.1.11)
                    arpData.entries.sort((a, b) => {
                        const pa = (a.ip || '').split('.').map(Number);
                        const pb = (b.ip || '').split('.').map(Number);
                        for (let i = 0; i < 4; i++) {
                            if ((pa[i] || 0) !== (pb[i] || 0)) return (pa[i] || 0) - (pb[i] || 0);
                        }
                        return 0;
                    });
                    
                    totalResults += arpData.entries.length;
                    html += '<div class="global-result-section">';
                    html += '<div class="global-result-header"><span>ARP Table Matches</span><span>' + arpData.entries.length + ' found</span></div>';
                    html += '<table class="data-table" style="table-layout:fixed"><thead><tr>';
                    html += '<th style="width:120px">Device</th><th style="width:150px">MAC Address</th><th style="width:110px">Interface</th><th style="width:130px">IP Address</th><th style="width:70px" class="text-right">VRF</th></tr></thead><tbody>';
                    
                    const arpEntriesToShow = arpData.entries.slice(0, 50);
                    arpEntriesToShow.forEach(entry => {
                        html += '<tr>';
                        html += '<td class="device">' + (entry.device || '-') + '</td>';
                        html += '<td class="mac">' + entry.mac + '</td>';
                        html += '<td>' + (entry.interface || '-') + '</td>';
                        html += '<td class="ip">' + entry.ip + '</td>';
                        html += '<td class="text-right">' + (entry.vrf || 'default') + '</td>';
                        html += '</tr>';
                    });
                    html += '</tbody></table></div>';
                }
                
                // Route Best Match (for all IP searches - VRF grouped with consistency check)
                // Uses cached routes for speed
                let hasRouteBestMatch = false;
                if (isIpSearch) {
                    try {
                        const routeResp = await fetch('search-api.sh?action=search-cached-routes&search=' + encodeURIComponent(searchTerm));
                        const routeData = await routeResp.json();
                        
                        if (routeData.success && routeData.vrf_routes && Object.keys(routeData.vrf_routes).length > 0) {
                            hasRouteBestMatch = true;
                            const vrfGroups = routeData.vrf_routes;
                            const sortedVrfs = sortVrfs(Object.keys(vrfGroups));
                            
                            // Build table format - same as device-specific search
                            html += '<div class="best-match-container" style="margin-bottom: 15px; padding: 12px 16px; background: linear-gradient(90deg, #3d3a1c, #1e1e1e); border-left: 3px solid #f0ad4e; border-radius: 4px;">';
                            html += '<div style="color: #f0ad4e; font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">';
                            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>';
                            html += 'No exact match for <span class="ip">' + searchTerm + '</span>. Showing best matching route(s):';
                            html += '</div>';
                            
                            html += '<table class="data-table" style="margin: 0;"><thead><tr>';
                            html += '<th>VRF</th><th>Best Match</th><th>Next Hop</th><th>Interface</th><th>Protocol</th><th style="text-align: right;">Devices</th></tr></thead><tbody>';
                            
                            sortedVrfs.forEach(vrf => {
                                const routes = vrfGroups[vrf];
                                const isNoRoute = routes.length === 1 && routes[0].no_route;
                                
                                if (isNoRoute) {
                                    html += '<tr style="opacity: 0.6;">';
                                    html += '<td><span class="badge ' + getVrfBadgeClass(vrf) + '">' + vrf + '</span></td>';
                                    html += '<td style="color: #888;">No Route</td>';
                                    html += '<td>-</td><td>-</td><td>-</td>';
                                    html += '<td style="text-align: right; color: #888;">-</td>';
                                    html += '</tr>';
                                } else {
                                    // Get first route info and count devices
                                    const r = routes[0];
                                    const deviceCount = routes.length;
                                    
                                    // Check for multiple nexthops
                                    const nexthops = new Set(routes.map(rt => rt.nexthop).filter(n => n));
                                    const nexthopDisplay = nexthops.size > 1 ? nexthops.size + ' next-hop' : (r.nexthop || '-');
                                    
                                    html += '<tr>';
                                    html += '<td><span class="badge ' + getVrfBadgeClass(vrf) + '">' + vrf + '</span></td>';
                                    html += '<td style="color: #f0ad4e;">' + r.prefix + '</td>';
                                    html += '<td class="ip">' + nexthopDisplay + '</td>';
                                    html += '<td>' + (r.interface || '-') + '</td>';
                                    html += '<td>' + (r.protocol || '-') + '</td>';
                                    html += '<td style="text-align: right; color: #76b900;">✓ ' + deviceCount + ' device</td>';
                                    html += '</tr>';
                                }
                            });
                            
                            html += '</tbody></table></div>';
                        }
                    } catch (e) {
                        console.error('Route search failed:', e);
                    }
                }
                
                if (totalResults === 0 && crossRefInfo.length === 0 && !hasRouteBestMatch) {
                    html = '<div class="status-message">No results found for "' + searchTerm + '"</div>';
                } else if (totalResults > 0) {
                    html = '<div style="margin-bottom: 10px; color: #76b900; font-weight: 600;">' + totalResults + ' total matches found</div>' + html;
                } else if (hasRouteBestMatch && totalResults === 0) {
                    // Only route best match found
                    html = '<div style="margin-bottom: 10px; padding: 10px 15px; background: linear-gradient(90deg, #3d3a1c, #1e1e1e); border-left: 3px solid #f0ad4e; border-radius: 4px;"><span style="color: #f0ad4e;">No exact match for <span class="ip">' + searchTerm + '</span> in MAC/ARP tables. Showing best matching routes:</span></div>' + html;
                }
                
                resultsDiv.innerHTML = html;
                
            } catch (e) {
                resultsDiv.innerHTML = '<div class="error-message">Search failed: ' + e.message + '</div>';
            }
        }
        
        // ============ ROUTE TABLE ============
        // Store route data for VRF filtering
        let currentRouteData = null;
        let currentRouteVrf = 'all';
        let fullRouteData = null; // Store full route table for best match search
        
        // VRF sorting function - default first, then alphabetical
        function sortVrfs(vrfNames) {
            return vrfNames.sort((a, b) => {
                if (a === 'default') return -1;
                if (b === 'default') return 1;
                return a.localeCompare(b);
            });
        }
        
        // VRF badge color function (consistent with vrf-report.html)
        function getVrfBadgeClass(vrfName) {
            if (!vrfName || vrfName === 'default') return 'badge-gray';
            
            // Infra VRFs get blue
            if (vrfName === 'oob' || vrfName === 'mgmt' || vrfName.toLowerCase().includes('mgmt') || vrfName.toLowerCase().includes('management')) {
                return 'badge-blue';
            }
            
            // Hash the VRF name to get consistent color
            const colors = ['badge-green', 'badge-purple', 'badge-orange', 'badge-cyan', 'badge-pink'];
            let hash = 0;
            for (let i = 0; i < vrfName.length; i++) {
                hash = ((hash << 5) - hash) + vrfName.charCodeAt(i);
                hash = hash & hash;
            }
            return colors[Math.abs(hash) % colors.length];
        }
        
        // IP prefix matching helper functions
        function ipToLong(ip) {
            const parts = ip.split('.').map(Number);
            return ((parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]) >>> 0;
        }
        
        function isIpInPrefix(ip, prefix) {
            // Parse prefix like "192.168.1.0/24"
            const [network, maskStr] = prefix.split('/');
            if (!maskStr) return false;
            
            const mask = parseInt(maskStr);
            if (mask < 0 || mask > 32) return false;
            
            const ipLong = ipToLong(ip);
            const networkLong = ipToLong(network);
            const maskBits = mask === 0 ? 0 : (0xFFFFFFFF << (32 - mask)) >>> 0;
            
            return (ipLong & maskBits) === (networkLong & maskBits);
        }
        
        function findBestMatchRoutes(searchIp, routeData) {
            // Find the best matching route (longest prefix match) per VRF
            // Show all VRFs, with "No Route" for those without a match
            const bestMatches = {};
            
            if (!routeData || !routeData.vrf_tables) return bestMatches;
            
            // Check if searchIp is a valid IP (not a prefix search)
            const ipMatch = searchIp.match(/^(\d+\.\d+\.\d+\.\d+)/);
            if (!ipMatch) return bestMatches;
            
            const ip = ipMatch[1];
            
            for (const vrf of (routeData.vrf_order || [])) {
                const routes = routeData.vrf_tables[vrf] || [];
                let bestMatch = null;
                let longestPrefix = -1;
                
                for (const route of routes) {
                    if (!route.prefix) continue;
                    
                    const [, maskStr] = route.prefix.split('/');
                    const mask = parseInt(maskStr || '32');
                    
                    if (isIpInPrefix(ip, route.prefix) && mask > longestPrefix) {
                        longestPrefix = mask;
                        bestMatch = { ...route, vrf };
                    }
                }
                
                if (bestMatch) {
                    bestMatches[vrf] = bestMatch;
                } else {
                    // No matching route for this VRF - mark as "No Route"
                    bestMatches[vrf] = { prefix: 'No Route', nexthop: '-', interface: '-', protocol: '-', vrf, no_route: true };
                }
            }
            
            return bestMatches;
        }
        
        function renderBestMatchResults(searchIp, bestMatches, container) {
            const vrfs = sortVrfs(Object.keys(bestMatches));
            if (vrfs.length === 0) {
                return '<div class="status-message">No routes found for ' + searchIp + '</div>';
            }
            
            let html = '<div class="best-match-container" style="margin-bottom: 15px; padding: 12px 16px; background: linear-gradient(90deg, #3d3a1c, #1e1e1e); border-left: 3px solid #f0ad4e; border-radius: 4px;">';
            html += '<div style="color: #f0ad4e; font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>';
            html += 'No exact match for <span class="ip">' + searchIp + '</span>. Showing best matching route(s):';
            html += '</div>';
            
            html += '<table class="data-table" style="margin: 0;"><thead><tr>';
            html += '<th>VRF</th><th>Best Match</th><th>Next Hop</th><th>Interface</th><th>Protocol</th></tr></thead><tbody>';
            
            vrfs.forEach(vrf => {
                const route = bestMatches[vrf];
                const isNoRoute = route.no_route;
                html += '<tr' + (isNoRoute ? ' style="opacity: 0.6;"' : '') + '>';
                html += '<td><span class="badge ' + getVrfBadgeClass(vrf) + '">' + vrf + '</span></td>';
                html += '<td style="color: ' + (isNoRoute ? '#888' : '#f0ad4e') + ';">' + route.prefix + '</td>';
                html += '<td class="ip">' + (route.nexthop || '-') + '</td>';
                html += '<td>' + (route.interface || '-') + '</td>';
                html += '<td>' + (route.protocol || '-') + '</td>';
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            return html;
        }
        
        async function loadRouteTable() {
            const device = document.getElementById('routeDeviceSelect').value;
            const search = document.getElementById('routeSearchInput').value.trim();
            const results = document.getElementById('routeResultsContent');
            const resultCount = document.getElementById('routeResultCount');
            const vrfTabsContainer = document.getElementById('vrfTabsContainer');
            const vrfTabs = document.getElementById('vrfTabs');
            
            if (!device) {
                results.innerHTML = '<div class="error-message">Please select a device</div>';
                vrfTabsContainer.style.display = 'none';
                return;
            }
            
            results.innerHTML = '<div class="loading-message">Loading routing table...</div>';
            vrfTabsContainer.style.display = 'none';
            
            try {
                const url = 'search-api.sh?action=get-route&device=' + encodeURIComponent(device) +
                            (search ? '&search=' + encodeURIComponent(search) : '');
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    currentRouteData = data;
                    currentRouteVrf = 'all';
                    
                    resultCount.textContent = data.total + ' routes';
                    
                    if (data.total === 0 || !data.vrf_order || data.vrf_order.length === 0) {
                        // No exact match - try to find best match
                        if (search && /^\d+\.\d+\.\d+\.\d+/.test(search)) {
                            // Load full routing table for best match search
                            results.innerHTML = '<div class="loading-message">Searching for best matching route...</div>';
                            try {
                                const fullUrl = 'search-api.sh?action=get-route&device=' + encodeURIComponent(device);
                                const fullResp = await fetch(fullUrl);
                                const fullData = await fullResp.json();
                                
                                if (fullData.success && fullData.total > 0) {
                                    fullRouteData = fullData;
                                    const bestMatches = findBestMatchRoutes(search, fullData);
                                    
                                    if (Object.keys(bestMatches).length > 0) {
                                        results.innerHTML = renderBestMatchResults(search, bestMatches);
                                        resultCount.textContent = 'Best match';
                                        vrfTabsContainer.style.display = 'none';
                                        return;
                                    }
                                }
                            } catch (e) {
                                console.error('Best match search failed:', e);
                            }
                        }
                        results.innerHTML = '<div class="status-message">No routes found</div>';
                        vrfTabsContainer.style.display = 'none';
                        return;
                    }
                    
                    // Build VRF tabs
                    let tabsHtml = '<button class="vrf-tab active" onclick="filterRoutesByVrf(\'all\')">All<span class="route-count">(' + data.total + ')</span></button>';
                    data.vrf_order.forEach(vrf => {
                        const count = (data.vrf_tables[vrf] || []).length;
                        tabsHtml += '<button class="vrf-tab" onclick="filterRoutesByVrf(\'' + vrf + '\')">' + vrf + '<span class="route-count">(' + count + ')</span></button>';
                    });
                    vrfTabs.innerHTML = tabsHtml;
                    vrfTabsContainer.style.display = 'block';
                    
                    // Render all routes
                    renderRouteTable(data, 'all', search);
                } else {
                    results.innerHTML = '<div class="error-message">' + (data.error || 'Failed to load') + '</div>';
                    vrfTabsContainer.style.display = 'none';
                }
            } catch (e) {
                results.innerHTML = '<div class="error-message">Error: ' + e.message + '</div>';
                document.getElementById('vrfTabsContainer').style.display = 'none';
            }
        }
        
        function filterRoutesByVrf(vrf) {
            if (!currentRouteData) return;
            currentRouteVrf = vrf;
            
            // Update tab styles
            document.querySelectorAll('.vrf-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.startsWith(vrf === 'all' ? 'All' : vrf)) {
                    tab.classList.add('active');
                }
            });
            
            const search = document.getElementById('routeSearchInput').value.trim();
            renderRouteTable(currentRouteData, vrf, search);
        }
        
        function renderRouteTable(data, selectedVrf, search) {
            const results = document.getElementById('routeResultsContent');
            const resultCount = document.getElementById('routeResultCount');
            
            let vrfsToShow = selectedVrf === 'all' ? data.vrf_order : [selectedVrf];
            let totalRoutes = 0;
            vrfsToShow.forEach(vrf => {
                totalRoutes += (data.vrf_tables[vrf] || []).length;
            });
            
            resultCount.textContent = totalRoutes + ' routes' + (selectedVrf !== 'all' ? ' in ' + selectedVrf : '');
            
            let html = '';
            
            // Single VRF or search mode - show single table
            if (selectedVrf !== 'all' || search) {
                html = '<table class="data-table" id="routeTable0"><thead><tr>';
                html += '<th>Prefix<span class="sort-icon"></span></th>';
                html += '<th>Next Hop<span class="sort-icon"></span></th>';
                html += '<th>Interface<span class="sort-icon"></span></th>';
                if (selectedVrf === 'all') html += '<th>VRF<span class="sort-icon"></span></th>';
                html += '<th>Protocol<span class="sort-icon"></span></th>';
                html += '<th>AD/Metric<span class="sort-icon"></span></th>';
                html += '<th data-numeric="true">ECMP<span class="sort-icon"></span></th>';
                html += '<th class="text-right">Age<span class="sort-icon"></span></th></tr></thead><tbody>';
                
                vrfsToShow.forEach(vrf => {
                    const routes = data.vrf_tables[vrf] || [];
                    routes.forEach(entry => {
                        html += '<tr>';
                        html += '<td class="ip">' + entry.prefix + '</td>';
                        html += '<td class="ip">' + (entry.nexthop || '-') + '</td>';
                        html += '<td>' + (entry.interface || '-') + '</td>';
                        if (selectedVrf === 'all') html += '<td><span class="badge badge-cyan">' + vrf + '</span></td>';
                        html += '<td>' + (entry.protocol || '-') + '</td>';
                        html += '<td>' + (entry.ad || '-') + '/' + (entry.metric || '-') + '</td>';
                        html += '<td>' + (entry.ecmp > 1 ? '<span class="badge badge-green">' + entry.ecmp + '</span>' : '1') + '</td>';
                        html += '<td class="text-right">' + (entry.age || '-') + '</td>';
                        html += '</tr>';
                    });
                });
                html += '</tbody></table>';
            } else {
                // Show All with separate VRF sections
                let tableIdx = 0;
                data.vrf_order.forEach(vrf => {
                    const routes = data.vrf_tables[vrf] || [];
                    if (routes.length === 0) return;
                    
                    html += '<div class="vrf-section">';
                    html += '<div class="section-header"><span class="section-title" style="color: var(--primary-green);">VRF: ' + vrf + '</span>';
                    html += '<span class="result-count">' + routes.length + ' routes</span></div>';
                    html += '<table class="data-table" id="routeTable' + tableIdx + '"><thead><tr>';
                    html += '<th>Prefix<span class="sort-icon"></span></th>';
                    html += '<th>Next Hop<span class="sort-icon"></span></th>';
                    html += '<th>Interface<span class="sort-icon"></span></th>';
                    html += '<th>Protocol<span class="sort-icon"></span></th>';
                    html += '<th>AD/Metric<span class="sort-icon"></span></th>';
                    html += '<th data-numeric="true">ECMP<span class="sort-icon"></span></th>';
                    html += '<th class="text-right">Age<span class="sort-icon"></span></th></tr></thead><tbody>';
                    
                    routes.forEach(entry => {
                        html += '<tr>';
                        html += '<td class="ip">' + entry.prefix + '</td>';
                        html += '<td class="ip">' + (entry.nexthop || '-') + '</td>';
                        html += '<td>' + (entry.interface || '-') + '</td>';
                        html += '<td>' + (entry.protocol || '-') + '</td>';
                        html += '<td>' + (entry.ad || '-') + '/' + (entry.metric || '-') + '</td>';
                        html += '<td>' + (entry.ecmp > 1 ? '<span class="badge badge-green">' + entry.ecmp + '</span>' : '1') + '</td>';
                        html += '<td class="text-right">' + (entry.age || '-') + '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table></div>';
                    tableIdx++;
                });
            }
            
            results.innerHTML = html;
            
            // Attach sort handlers
            document.querySelectorAll('[id^="routeTable"]').forEach(table => {
                attachSortHandlers(table);
            });
        }
        
        // ============ LLDP NEIGHBORS ============
        async function loadLldpNeighbors() {
            const device = document.getElementById('lldpDeviceSelect').value;
            const search = document.getElementById('lldpSearchInput').value.trim();
            const results = document.getElementById('lldpResultsContent');
            const resultCount = document.getElementById('lldpResultCount');
            
            if (!device) {
                results.innerHTML = '<div class="error-message">Please select a device</div>';
                return;
            }
            
            results.innerHTML = '<div class="loading-message">Loading LLDP neighbors...</div>';
            
            try {
                const url = 'search-api.sh?action=get-lldp&device=' + encodeURIComponent(device) +
                            (search ? '&search=' + encodeURIComponent(search) : '');
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    resultCount.textContent = data.entries.length + ' neighbors';
                    
                    if (data.entries.length === 0) {
                        results.innerHTML = '<div class="status-message">No LLDP neighbors found</div>';
                        return;
                    }
                    
                    let html = '<table class="data-table" id="lldpTable"><thead><tr>';
                    html += '<th>Local Port<span class="sort-icon"></span></th>';
                    html += '<th>Neighbor<span class="sort-icon"></span></th>';
                    html += '<th>Remote Port<span class="sort-icon"></span></th>';
                    html += '<th class="text-right">Remote IP<span class="sort-icon"></span></th></tr></thead><tbody>';
                    
                    data.entries.forEach(entry => {
                        html += '<tr>';
                        html += '<td>' + entry.local_port + '</td>';
                        html += '<td class="device">' + entry.neighbor + '</td>';
                        html += '<td>' + (entry.remote_port || '-') + '</td>';
                        html += '<td class="ip text-right">' + (entry.mgmt_ip || '-') + '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    results.innerHTML = html;
                    attachSortHandlers(document.getElementById('lldpTable'));
                } else {
                    results.innerHTML = '<div class="error-message">' + (data.error || 'Failed to load') + '</div>';
                }
            } catch (e) {
                results.innerHTML = '<div class="error-message">Error: ' + e.message + '</div>';
            }
        }
        
        // ============ EXPORT ============
        function exportTable(type) {
            const data = type === 'mac' ? currentMacData : currentArpData;
            if (!data || data.length === 0) {
                alert('No data to export');
                return;
            }
            
            let csv = '';
            if (type === 'mac') {
                csv = 'Device,MAC,Interface,VLAN\n';
                data.forEach(e => {
                    csv += '"' + (e.device || '') + '","' + e.mac + '","' + (e.interface || '') + '","' + (e.vlan || '') + '"\n';
                });
            } else {
                csv = 'Device,IP,MAC,Interface,VRF,State\n';
                data.forEach(e => {
                    csv += '"' + (e.device || '') + '","' + e.ip + '","' + e.mac + '","' + (e.interface || '') + '","' + (e.vrf || '') + '","' + (e.state || '') + '"\n';
                });
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = type + '-table-' + new Date().toISOString().slice(0,10) + '.csv';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Enter key support
        document.getElementById('macSearchInput').addEventListener('keypress', e => { if (e.key === 'Enter') loadMacTable(); });
        document.getElementById('arpSearchInput').addEventListener('keypress', e => { if (e.key === 'Enter') loadArpTable(); });
        document.getElementById('vtepSearchInput').addEventListener('keypress', e => { if (e.key === 'Enter') loadVtepTable(); });
        document.getElementById('routeSearchInput').addEventListener('keypress', e => { if (e.key === 'Enter') loadRouteTable(); });
        document.getElementById('lldpSearchInput').addEventListener('keypress', e => { if (e.key === 'Enter') loadLldpNeighbors(); });
        
        // Check scan status
        async function checkScanStatus() {
            try {
                const response = await fetch('search-api.sh?action=scan-status');
                const data = await response.json();
                const statusSpan = document.getElementById('scanStatus');
                
                if (data.success && data.timestamp) {
                    const ageMin = data.age_minutes;
                    let ageText = '';
                    if (ageMin < 1) ageText = 'just now';
                    else if (ageMin < 60) ageText = ageMin + 'm ago';
                    else ageText = Math.floor(ageMin / 60) + 'h ago';
                    
                    statusSpan.innerHTML = '<span style="color:#76b900;">' + data.device_count + ' devices</span> • ' + ageText;
                } else {
                    statusSpan.innerHTML = '<span style="color:#f59e0b;">No cached data</span>';
                }
            } catch (e) {
                document.getElementById('scanStatus').innerHTML = '';
            }
        }
        
        // Init
        window.onload = function() {
            setLastUpdated();
            loadDeviceList();
            checkScanStatus();
        };
    </script>
</body>
</html>
